In this document, we demonstrate how to solve a two-\/dimensional Biharmonic equation using triangular finite elements within {\ttfamily oomph-\/lib}.

First, let consider the Biharmonic equation which is mathematically expressed as follow

\[ \frac{\partial^4 u}{\partial x_1^4} + 2\frac{\partial^4 u}{\partial x_1^2\partial x_2^2} + \frac{\partial^4 u}{\partial x_2^4} = f(x_1,x_2), \ \ \ \mathbf{x} = (x_1,x_2) \in \Re^2. \ \ \ \ (1) \]

In this study, we consider the homogeneous Biharmonic equation with the exact solution \[ u(x_1,x_2) = \cos(x_1)e^{x_2}. \]

The problem will be implemented in the rectangular domain $ \Omega = \{(x_1,x_2) | 0 \leq x_1 \leq 2, 0\leq x_2 \leq 1 \} $, and we apply Dirichlet boundary conditions such that the exact solution is satisfied.

In order to formulate the finite element implementation of the Biharmonic equation, the weak formulation must be derived. The reader is referred to \href{../../../intro/html/index.html}{\texttt{ another document}} for detailed descriptions of weak formulations.

After introducing the weight or test function $ \phi(x_i) $ and changing the differential equation (1) into the integral form, we have \[ 0 = r = \int_{\Omega}{\left( \frac{\partial^4 u}{\partial x_1^4} + 2\frac{\partial^4 u}{\partial x_1^2\partial x_2^2} + \frac{\partial^4 u}{\partial x_2^4} - f(x_i)\right) \phi(x_i) d\Omega.} \ \ \ (2) \]

Integrating by parts twice and using of the divergence theorem give

\[ 0 = r = \int_{\Omega}{\left( \frac{\partial^2 u}{\partial x_1^2}\frac{\partial^2 \phi}{\partial x_1^2} + 2\frac{\partial^2 u}{\partial x_1^2}\frac{\partial^2 \phi}{\partial x_2^2} + \frac{\partial^2 u}{\partial x_2^2}\frac{\partial^2 \phi}{\partial x_2^2} - f(x_i)\phi(x_i)\right) d \Omega} \] \[ + \int_{\partial \Omega} \nabla^3_n u \phi(x_i) d\partial \Omega - \int_{\partial \Omega} \nabla^2 u \frac{\partial \phi}{\partial n}(x_i) d\partial \Omega, \ \ \ \ \ (3) \]

where $ \partial \Omega $ denotes the domain boundary and $ \partial/\partial n $ the outward normal derivative. Since the test functions satisfy homogeneous boundary conditions, $ \left. \phi \right|_{\partial \Omega} = 0 = \left. \frac{\partial \phi}{\partial n}\right|_{\partial \Omega}, $ the integrals for the last two terms of equation (3) vanish.

Therefore, an alternative version of the weak form of (1) is given by

\[ 0 = r = \int_{\Omega}{\left( \frac{\partial^2 u}{\partial x_1^2}\frac{\partial^2 \phi}{\partial x_1^2} + 2\frac{\partial^2 u}{\partial x_1^2}\frac{\partial^2 \phi}{\partial x_2^2} + \frac{\partial^2 u}{\partial x_2^2}\frac{\partial^2 \phi}{\partial x_2^2} - f(x_i)\phi(x_i)\right) d \Omega.} \ \ \ \ \ (4) \]

It is noteworthy that the Galerkin method is employed in this study so that the choice of function spaces for the solution, $u(x_i)$, and the test function, $\phi(x_i)$, is the same. Therefore, both the solution and the test function can be approximated by the same set of shape function, $\psi_l$ as

\[ u(x_i) = \sum_{l=1}^{N} U_{l}\psi_l(x_i), \ \ \ \ (5) \] and, \[ \phi(x_i) = \sum_{k=1}^{N} \Phi_{k}\psi_k(x_i), \ \ \ \ (6) \] where $ N $ is the dimension of discrete approximating to function space.

Substituting the derivatives of (6) into (4), we have

\[ 0 = r = \int_{\Omega}{\left( \frac{\partial^2 u}{\partial x_1^2}\sum_{k=1}^{N} \Phi_{k}\frac{\partial^2 \psi_{k}}{\partial x_1^2} + 2\frac{\partial^2 u}{\partial x_1^2}\sum_{k=1}^{N} \Phi_{k}\frac{\partial^2 \psi_{k}}{\partial x_2^2} + \frac{\partial^2 u}{\partial x_2^2}\sum_{k=1}^{N} \Phi_{k}\frac{\partial^2 \psi_{k}}{\partial x_2^2} - f(x_i)\sum_{k=1}^{N} \Phi_{k}\psi_{k}(x_i)\right) d \Omega,} \]

\[ 0 = r = \sum_{k=1}^{N}{\Phi_{k} r_{k}(U_1,U_2,...,U_N)}, \ \ \ \ (7) \]

where

\[ r_{k}(U_1,U_2,...,U_N) = \int_{\Omega}{\left( \frac{\partial^2 u}{\partial x_1^2}\frac{\partial^2 \psi_{k}}{\partial x_1^2} + 2\frac{\partial^2 u}{\partial x_1^2}\frac{\partial^2 \psi_{k}}{\partial x_2^2} + \frac{\partial^2 u}{\partial x_2^2}\frac{\partial^2 \psi_{k}}{\partial x_2^2} - f(x_i)\psi_{k}(x_i)\right) d \Omega.} \ \ \ \ (8) \]

We have that (7) must hold for any value of the coefficients $ \Phi_k $, so the coefficients $ U_j $ must satisfy the equations

\[ r_k(U_1, U_2,...,U_N) = 0, \mbox{ \ \ \ \ for } k=1,2,...,N. \] ~\newline


After substituting the derivatives of (5) into (8), the weak form of (1) can be expressed as

\[ 0 = r_{k} = \int_{\Omega}\left( \sum_{l=1}^{N}{U_l\frac{\partial^2 \psi_l}{\partial x_1^2}}\frac{\partial^2\psi_k}{\partial x_1^2} + 2\sum_{l=1}^{N}{U_l\frac{\partial^2 \psi_l}{\partial x^2_1}}\frac{\partial^2\psi_k}{\partial x^2_2} + \sum_{k=1}^{N}{U_l\frac{\partial^2 \psi_l}{\partial x_2^2}}\frac{\partial^2\psi_k}{\partial x_2^2} - f(x_i)\psi_k \right) dx_1dx_2. \ \ (9) \]

Since we solve the Biharmonic equation with the Dirichlet boundary conditions in this study, the boundary terms in (9) vanish. This is a consequence of every test functions have to satisfy the homogeneous conditions at boundaries. Now, it can be seen that the weak formulation of the equation contains the second-\/order derivatives of the approximation, $ \psi(x_i) $ of the solution. Hence, in order to make the integral exists, the approximation and its first-\/order derivative are required to be continuous. Therefore, the $ C^1 $-\/interpolations are required.

Hence, the {\ttfamily Bell\+Element} is introduced in this document to provide the continuously differentiable shape functions to interpolate the solution of a Biharmonic equation. This kind of element arises in order to satisfy $ C^1 $ continuity of the solutions of a fourth-\/order problem.

Specifically, we shall provide


\begin{DoxyItemize}
\item a general descriptions of the Bell triangular finite element
\end{DoxyItemize}
\begin{DoxyItemize}
\item numerical results of solving the Biharmonic equation with the {\ttfamily Bell\+Element} 
\end{DoxyItemize}and
\begin{DoxyItemize}
\item how to implement the {\ttfamily Bell\+Element} in {\ttfamily oomph-\/lib} using the Biharmonic equation as a case study.
\end{DoxyItemize}\DoxyHorRuler{0}
 ~\newline
 \DoxyHorRuler{0}
\hypertarget{index_overview}{}\doxysection{Overview of the Bell\+Element}\label{index_overview}
The constructed {\ttfamily Bell\+Element} provides a discretisation of the variational principle (9) with two-\/dimensional, three-\/node triangular finite elements. In this element, the subparametric idea is employed. This means that the degree of geometric shape functions (shape function approximated a geometry) is defined to be lower than the degree of polynomials for parametric shape functions (shape function approximated a variable). In this study, a geometry is approximated by the linear Lagrange polynomials while the Bell shape functions are employed to interpolate variables.

The two-\/dimensional linear Lagrange shape functions defined over a triangle are parametrised by the local coordinates $ s_1,s_2 \in [0,1]$ and are defined as

\[ \psi_{1}(s_1,s_2) = s_1, \ \ \ \psi_{2}(s_1,s_2) = s_2, \ \ \ \psi_{3}(s_1,s_2) = 1-s_1-s_2. \ \ \ \ \ (10)\]

Therefore, a position $ {\bf x} = (x_1,x_2) \in \Re^2 $ is approximated by

\[ x_i(s_1,s_2) = \sum_{j=1}^{3} X_{ij} \ \psi_{j}(s_1,s_2) \mbox{\ \ \ for $i=1,2$}, \ \ \ \ \ \ \ \ (11) \] where $ X_{ij} $ are the nodal positions in the direction $ i^{th} $ at node $ j $.

Similar to a geometric approximation, a variable can be approximated as

\[ u_i(x_1,x_2) = \sum_{l=1}^{3} \sum_{k=1}^{6}U_{ilk} \ \varphi_{lk}(\lambda_1,\lambda_2,\lambda_3), \] where $ x_1,x_2 \in \Omega $ are the element\textquotesingle{}s 2D global coordinates. The function $ \varphi_{lk}$ are the two-\/dimensional Bell shape functions parametrised by area coordinates $ \lambda_1, \lambda_2, \lambda_3$ which we will describe in the next two subsections.

\DoxyHorRuler{0}
\hypertarget{index_area_coor}{}\doxysubsection{Area coordinates}\label{index_area_coor}
The area coordinate system or Barycentric coordinates are defined on a triangle which is expressed in terms of its three vertices. We consider a triangle defined by three vertices $ {\bf x}_{1}, {\bf x}_{2}, {\bf x}_{3}$ as

 
\begin{DoxyImage}
\includegraphics[width=0.55\textwidth]{triangle}
\doxyfigcaption{The geometry of a triangle which has three nodes. }
\end{DoxyImage}


The barycentric coordinates of point $ {\bf p} = (x,y)$ in the triangle are simply defined to be ratios of triangular areas as, \[ \lambda_1 = \frac{A_1}{A}, \ \ \ \lambda_2 = \frac{A_2}{A}, \ \ \ \lambda_3 = \frac{A_3}{A}. \ \ \ \ (12) \]

Area $ A $ is the total area of the triangle and can be computed as \[ A = \frac{1}{2}\left(\left(x_2y_3-x_3y_2\right) + \left(x_3y_1-x_1y_3\right) + \left(x_1y_2-x_2y_1\right)\right).\]

Also, $ A_j, j=1,2,3 $ are the sub-\/area of the triangle described in the figure. They can be computed as \[ A_1 = \frac{1}{2}\left(\left(x_2y_3-x_3y_2\right) + \left(x_3y-xy_3\right) + \left(xy_2-x_2y\right)\right),\] \[ A_2 = \frac{1}{2}\left(\left(xy_3-x_3y\right) + \left(x_3y_1-x_1y_3\right) + \left(x_1y-xy_1\right)\right),\] \[ A_3 = \frac{1}{2}\left(\left(x_2y-xy_2\right) + \left(xy_1-x_1y\right) + \left(x_1y_2-x_2y_1\right)\right),\]

where $ x_i,y_i $ denotes the $ x- $ and $ y- $ coordinates of the point $ \mathbf{x}_i;i =1,2,3. $ These ratios of areas form dimensionless coordinates in the plane defined by points $ {\bf x}_{1}, {\bf x}_{2}, {\bf x}_{3}. $

A barycentric combination of three points takes the form\+: $ {\bf p} = \lambda_1{\bf x}_{1} + \lambda_2{\bf x}_{2} + \lambda_3{\bf x}_{3}$ where $ \lambda_1+\lambda_2+\lambda_3 = 1.$ The third area coordinate $ \lambda_3 $ can be expressed as $ \lambda_3 = 1-\lambda_1-\lambda_2. $

The three vertices have the barycentric coordinates as \[ {\bf x}_{1} = \left(1,0,0\right), \ \ \ {\bf x}_{2} = \left(0,1,0\right), \ \ \ {\bf x}_{3} = \left(0,0,1\right). \]

\DoxyHorRuler{0}
\hypertarget{index_bell_shape}{}\doxysubsection{The Bell shape functions}\label{index_bell_shape}
The shape functions of the Bell element are defined over a triangle and derived from the quintic polynomials with 18 degrees of freedom. The element comprises three nodes with six degrees of freedom at each corner node including the value, and all first and second derivatives; $ u, u_{x}, u_{y}, u_{xx}, u_{yy}, u_{xy}. $ The graphical description of the Bell element is illustrated below.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{bell_element}
\doxyfigcaption{(Left)The Bell element with 18 degrees of freedom; 6 dofs at vertices. (Right) The description of all parameters utilised within the derivation of the Bell shape functions. }
\end{DoxyImage}


The shape functions of the Bell element are parametrised by area coordinates, $\lambda_j$. The subscripts $ik$ of the shape functions $\psi_{ik}$ mean that they are evaluated at node $i$ with $k^{th}$ degree of freedom where $k=1$ denotes degree of freedom that corresponds to the unknown value, $k=2,3$ correspond to the first derivatives with respect to the first and second global coordinates, $k=4,5$ correspond to the second derivatives with respect to the first and second global coordinates, and $k=6$ corresponds to the mixed derivative.

Unlike the Lagrangian interpolation functions, the Bell shape functions are derived by interpolating nodal derivatives as well as nodal displacements. Also, they have to satisfy the properties that $\psi_{i1} = 1$ at node $i$ and $\psi_{i1} = 0$ at other nodes. Furthermore, all of the first and the second derivatives of $\psi_{i1} = 0$ at all nodes. Also, $\partial_{x}\psi_{i2} = 1$ at node $i$ and $\partial_{x}\psi_{i2} = 0$ at other nodes. Similarly for the first derivative with respect to $y$, we have that $\partial_{y}\psi_{i3} = 1$ at node $i$ and $\partial_{y}\psi_{i3} = 0$ at other nodes. These shape functions associated with the first derivatives are zero at all nodes for $\psi_{im}$, $\partial_{xx}\psi_{im}$, $\partial_{yy}\psi_{im}$, $\partial_{xy}\psi_{im}, \forall m=2,3$. Moreover, $\partial_{xx}\psi_{i4}(\mathbf{x}_{k}) = \delta_{ik}$, $\partial_{yy}\psi_{i5}(\mathbf{x}_{k}) = \delta_{ik}$, and $\partial_{xy}\psi_{i6}(\mathbf{x}_{k}) = \delta_{ik}$. Furthermore, these shape functions associated with the second derivatives are zero at all nodes for $\psi_{im}$, $\partial_{x}\psi_{im}$, and $\partial_{y}\psi_{im}, \forall m=4,5,6$.

The Bell shape functions are mathematically expressed as

\[ \psi_{11}(\lambda_1,\lambda_2,\lambda_3) = \lambda_1^5 + 5\lambda_1^4\left( \lambda_2+\lambda_3\right) + 10\lambda_1^3\left( \lambda_2+\lambda_3\right)^2 + 30\lambda_1^2\lambda_2\lambda_3\left( l_3\lambda_2 + l^{\prime}_2\lambda_3\right), \] \[ \psi_{12}(\lambda_1,\lambda_2,\lambda_3) = 3b_1\lambda_1^2\lambda_2\lambda_3\left( \lambda_2-\lambda_3\right) + \lambda_1^3\left(b_3\lambda_2 -b_2\lambda_3 \right)\left( \lambda_1+4\lambda_2+4\lambda_3\right) \] \[ + 15\lambda_1^2\lambda_2\lambda_3\left( b_3l_3\lambda_2-b_2l^{\prime}_2\lambda_3\right), \] \[ \psi_{13}(\lambda_1,\lambda_2,\lambda_3) = -3c_1\lambda_1^2\lambda_2\lambda_3\left( \lambda_2-\lambda_3\right) - \lambda_1^3\left(c_3\lambda_2 -c_2\lambda_3 \right)\left( \lambda_1+4\lambda_2+4\lambda_3\right) \] \[ - 15\lambda_1^2\lambda_2\lambda_3\left( c_3l_3\lambda_2-c_2l^{\prime}_2\lambda_3\right), \] \[ \psi_{14}(\lambda_1,\lambda_2,\lambda_3) = 1/2\lambda_1^3\left( b_3^2\lambda_2^2+b_2^2\lambda_3^2\right) + \lambda_1^2\lambda_2\lambda_3\left(-b_2b_3\lambda_1 + b_3b_1\lambda_2 + b_1b_2\lambda_3 \right) \] \[ + 5/2\lambda_1^2\lambda_2\lambda_3\left( b_3^2l_3\lambda_2+b_2^2l^{\prime}_2\lambda_3\right), \] \[ \psi_{15}(\lambda_1,\lambda_2,\lambda_3) = 1/2\lambda_1^3\left( c_3^2\lambda_2^2+c_2^2\lambda_3^2\right) + \lambda_1^2\lambda_2\lambda_3\left(-c_2c_3\lambda_1 + c_3c_1\lambda_2 + c_1c_2\lambda_3 \right) \] \[ + 5/2\lambda_1^2\lambda_2\lambda_3\left( c_3^2l_3\lambda_2+c_2^2l^{\prime}_2\lambda_3\right), \] \[ \psi_{16}(\lambda_1,\lambda_2,\lambda_3) = b_1c_1\lambda_1^2\lambda_2\lambda_3\left( \lambda_1+\lambda_2+\lambda_3\right) + b_2c_2\lambda_1^2\lambda_3\left( \lambda_2\lambda_3 - \lambda_3\lambda_1 - \lambda_1\lambda_2 - \lambda_2^2\right) \] \[ + b_3c_3\lambda_1^2\lambda_2\left( \lambda_2\lambda_3 - \lambda_3\lambda_1 - \lambda_1\lambda_2 - \lambda_3^2\right) - 5\lambda_1^2\lambda_2\lambda_3\left( b_2c_2l^{\prime}_2\lambda_3 + b_3c_3l_3\lambda_2\right). \ \ \ \ (13)\]

These are shape functions associated with the first node with its 6 degrees of freedom. The shape functions at another two nodes can be obtained by performing a cyclic permutation of the Barycentric coordinates in (13). The parameters $ b_i, c_i \forall i = 1,2,3, $ appearing in the equations can be obtained from

\[ b_1 = x_3 - x_2, \ \ \ b_2 = x_1-x_3, \ \ \ b_3 = x_2 - x_1, \] \[ c_1 = y_2 - y_3, \ \ \ c_2 = y_3-y_1, \ \ \ c_3 = y_1 - y_2, \] where $x_i,y_i; i=1,2,3,$ are components of a vertex $\mathbf{x}_i. $

Note that all the first and second derivatives can be obtained by the help of the chain rule as

\[ \frac{\partial \psi_{ij}}{\partial x_{\alpha}} = \frac{\partial \psi_{ij}}{\partial \lambda_{k}}\frac{\partial \lambda_{k}}{\partial x_{\alpha}}, \] \[ \frac{\partial^2 \psi_{ij}}{\partial x_{\alpha}\partial x_{\beta}} = \frac{\partial^2 \psi_{ij}}{\partial \lambda_{m}\partial \lambda_{n}}\frac{\partial \lambda_{m}}{\partial x_{\alpha}}\frac{\partial \lambda_{n}}{\partial x_{\beta}} + \frac{\partial^2 \lambda_{k}}{\partial x_{\alpha}\partial x_{\beta}}\frac{\partial \psi_{ij}}{\partial \lambda_{k}}, \]

and the derivatives of area coordinates with respect to global coordinates can be obtained from considering (12) with the substitutions of $ b_i, c_i; i=1,2,3. $ They are expressed as follows\+:

\[ \frac{\partial \lambda_{1}}{\partial x} = \frac{c_1}{2A}, \ \ \ \frac{\partial \lambda_{2}}{\partial x} = \frac{c_2}{2A}, \ \ \ \frac{\partial \lambda_{3}}{\partial x} = \frac{c_3}{2A}, \]

\[ \frac{\partial \lambda_{1}}{\partial y} = \frac{b_1}{2A}, \ \ \ \frac{\partial \lambda_{2}}{\partial y} = \frac{b_2}{2A}, \ \ \ \frac{\partial \lambda_{3}}{\partial y} = \frac{b_3}{2A}. \]

Here are graphical Bell shape functions at the first node, $ \psi_{1j}, j=1,...,6,$ evaluated at $ {\bf x}_1 $. The figures show that the Bell shape function at the first node have to satisfy the properties that $\psi_{11} = 1$ at node $1$ and $\psi_{11} = 0$ at other nodes. Furthermore, all of the Bell shape functions corresponded to all first and second derivatives $ \psi_{1j} = 0, j=2,...,6 $ at all nodes.

 
\begin{DoxyImage}
\includegraphics[width=1.05\textwidth]{shapes}
\doxyfigcaption{The Bell shape functions that correspond to the 6 degrees of freedom defined previously at the first node. Here the shape functions are evaluated at x1 which show the appreciation of the crucial properties in the Bell shape functions. }
\end{DoxyImage}


Note that the Bell shape functions and also the first and second derivatives are differentiated with respect to global coordinates. Therefore, the Jacobian of mapping between global to local coordinates is no longer needed to derive the derivatives of the shape functions for this type of element.

\DoxyHorRuler{0}
\hypertarget{index_interface}{}\doxysubsection{The interface of accessible functions to the shape functions in the Bell\+Element}\label{index_interface}
Since the {\ttfamily Bell\+Element} is constructed with the subparametric idea, there are two sets of approximating functions defined in the element. The linear Lagrange polynomials defined in (10) will be inherited from {\ttfamily T\+Element\+Shape$<$2,2$>$} in order to approximate the geometry. These functions can be accessible by

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\ttfamily Bell\+Element$<$$>$\+::shape(s,psi)}. \end{center}    \\\cline{1-1}
\end{longtabu}
\end{center} 

In order to approximate variables in the {\ttfamily Bell\+Element}, the Bell shape functions defined in (13) will be overloaded from {\ttfamily Bell\+Element\+Shape\+::\+Bshape(...)}. This function will compute the basis functions at local coordinate $ s $ and it provides $ C^1 $-\/continuity.

As the global coordinates are required in the derivation of the shape functions of the {\ttfamily Bell\+Element\+Shape$<$$>$}, the physical coordinates of vertices have to be passed as an argument when shape functions are overloaded. The interface of the Bell shape functions obtained from {\ttfamily Bell\+Element\+Shape$<$$>$} at local coordinate $ s $ is {\ttfamily Bell\+Element\+Shape$<$$>$\+::\+Bshape(s,psi,position)}. Similarly, the first and the second-\/order derivatives can be obtained at local coordinate $ s $ as {\ttfamily Bell\+Element\+Shape$<$$>$\+::d\+Bshape(s,psi,dpsi,position)} and {\ttfamily Bell\+Element\+Shape$<$$>$\+::d2\+Bshape(s,psi,dpsi,d2psi,position)}, respectively.

Note that the vector {\ttfamily position} is the collection of coordinates on vertices of Bell triangles. The order of nodal positions defined in the vector {\ttfamily position} is correspond with the order of those on physical elements. Also, the vertex nodes 0,1, and 2 situate anticlockwise.

Now, to obtained the basis functions that employed to approximate variables in {\ttfamily Bell\+Element}, they can be accessible via

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\ttfamily Bell\+Element$<$$>$\+::basis(s,psi)}, \end{center}    \\\cline{1-1}
\end{longtabu}
\end{center} 

and, the first and second-\/order derivatives of the Bell shape functions can be accessible via

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\ttfamily Bell\+Element$<$$>$\+::dbasis(s,psi,dpsi)} {\ttfamily Bell\+Element$<$$>$\+::d2basis(s,psi,dpsi,d2psi)}, \end{center}    \\\cline{1-1}
\end{longtabu}
\end{center}  respectively.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_reslt}{}\doxysection{Results}\label{index_reslt}
Before the numerical results obtained from solving the 2D Biharmonic equation with the Bell finite element will be illustrated, the boundary conditions have to be specified. Since the Bell finite element is employed, the boundary specifications have to correspond with degrees of freedom defined for the {\ttfamily Bell\+Element} in the previous section.

Since we consider the Biharmonic equation with the Dirichlet boundary conditions, we have that the physical conditions that allow to be pinned on boundaries are the value and the normal derivatives. However, there is no normal derivative defined as a degree of freedom to be specified for the Bell shape function. Therefore, the first-\/order derivatives have to be imposed instead and the boundary specification can be worked out from the normal derivative on that boundary.

Furthermore, the values of the unknown and the first-\/order derivatives that have to be specified on the boundaries of the domain for the Bell element can be obtained from

\[ u(x_1,x_2) = \cos(x_1)e^{x_2} , \ \ \ u_{x_1}(x_1,x_2) = -\sin(x_1)e^{x_2}, \ \ \ u_{x_2}(x_1,x_2) = \cos(x_1)e^{x_2}. \ \ \ (14) \]

For the rest of degrees of freedom associated with the second-\/order derivatives, they are derived conditions that can be taken care by the natural boundary conditions. In this study, we set them to be pinned in order to reduce the number of degrees of freedom in the problem. The values of the second-\/order derivatives that have to be specified on the boundaries of the domain for the Bell element can be worked out from (14) and are expressed as

\[ u_{x_1x_1}(x_1,x_2) = -\cos(x_1)e^{x_2} , \ \ \ u_{x_1x_2}(x_1,x_2) = -\sin(x_1)e^{x_2}, \ \ \ u_{x_2x_2}(x_1,x_2) = \cos(x_1)e^{x_2}. \]

The following is a table illustrating the performance with the associated computational time of the Bell triangular elements. The accuracy of the solutions will base on the $L^2$-\/norm error which is mathematically described as \[ |u_{exact}-u_{FE}| = \left( \int_{\Omega} | u_{exact} - u_{FE}|^2 d\Omega \right)^{1/2}, \] where $u_{exact},u_{FE}$ denote the exact and the finite element solutions, respectively.

{\bfseries{Table 1\+:}} $L^2$-\/norm error of the solution obtained from the Biharmonic implementation using the Bell element with various numbers of elements.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
Element size (h)  &Number of elements  &Number of dofs  &Error  &Time (sec)   \\\cline{1-5}
0.\+5  &16  &18  &$ 3.45428 \times 10^{-5} $  &0.\+18   \\\cline{1-5}
0.\+2  &100  &216  &$ 7.78578 \times 10^{-7} $  &1.\+19   \\\cline{1-5}
0.\+1429  &196  &468  &$ 1.89314 \times 10^{-7} $  &3.\+74   \\\cline{1-5}
0.\+1  &400  &1026  &$ 4.29805 \times 10^{-8} $  &4.\+77   \\\cline{1-5}
0.\+005  &1600  &4446  &$ 2.52419 \times 10^{-9} $  &19.\+67   \\\cline{1-5}
0.\+01  &40000  &118206  &$ 3.86145 \times 10^{-12} $  &1197.\+06     \\\cline{1-5}
\end{longtabu}
~\newline
 \end{center} 

The figures below illustrate, respectively, the finite element solution and absolute error obtained from solving the Biharmonic equation with the {\ttfamily Bell\+Element} on structured meshes. This implementation employs 16 triangular elements in the mesh with the number of degrees of freedom equals to 18.

 
\begin{DoxyImage}
\includegraphics[width=0.55\textwidth]{Biharmonic_Bell_Soln}
\doxyfigcaption{The finite element solution of the Biharmonic equation obtained from the Bell\+Element. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.55\textwidth]{Biharmonic_Bell_Err}
\doxyfigcaption{Absolute error between the exact and the finite element solutions of the Biharmonic equation obtained from the Bell\+Element. }
\end{DoxyImage}


Next, plotting the logarithm of $ L^2 $-\/error with that of the element size shows that the obtained rate of convergence of the Bell element is quartic (see figure 1.\+4).

 
\begin{DoxyImage}
\includegraphics[width=0.55\textwidth]{Bell_Err_log}
\doxyfigcaption{A log-\/plot between error and the element size from solving the Biharmonic equation with the Bell\+Element in a rectangular domain. }
\end{DoxyImage}


\DoxyHorRuler{0}
 ~\newline
 \DoxyHorRuler{0}
\hypertarget{index_impl}{}\doxysection{Implementation in oomph-\/lib}\label{index_impl}
\DoxyHorRuler{0}
\hypertarget{index_global}{}\doxysubsection{Global parameters and functions}\label{index_global}
The namespace {\ttfamily \mbox{\hyperlink{namespacePhysical__Variables}{Physical\+\_\+\+Variables}}} is where the source function and the exact solution are defined. The source function can be specified via {\ttfamily \mbox{\hyperlink{namespacePhysical__Variables_ae11027d76c5f512b7db6a1b6d17dc792}{Physical\+\_\+\+Variables\+::source\+\_\+function()}}} while the exact solutions are defined via {\ttfamily \mbox{\hyperlink{namespacePhysical__Variables_af90d0c580c57b1152fd1cc7046055031}{Physical\+\_\+\+Variables\+::get\+\_\+exact\+\_\+u()}}}. Note that the six exact solutions correspond to the six degrees of freedom defined on each node.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_namespace================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Namespace for the solution of 2D Biharmonic equation}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespacePhysical__Variables}{Physical\_Variables}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// number of elements in the x direction}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \mbox{\hyperlink{namespacePhysical__Variables_ae766d6695cfb9a8d87be9767b38245ff}{n\_x}} = 4;}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// number of elements in the y direction}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \mbox{\hyperlink{namespacePhysical__Variables_a35801b250816fa72ce9023f8738515fa}{n\_y}} = 2;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// length in the x direction}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespacePhysical__Variables_af92161eeeab3e15a31698af80f8d09db}{l\_x}} = 2.0;}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// length in the y direction}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespacePhysical__Variables_a9f73110ebbfe999c6f09ac797793a537}{l\_y}} = 1.0;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Exact solution as a Vector}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacePhysical__Variables_af90d0c580c57b1152fd1cc7046055031}{get\_exact\_u}}(\textcolor{keyword}{const} Vector<double>\& x, Vector<double>\& \mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}})}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}}[0] = cos(x[0])*exp(x[1]);}
\DoxyCodeLine{  \mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}}[1] = -\/sin(x[0])*exp(x[1]);}
\DoxyCodeLine{  \mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}}[2] = cos(x[0])*exp(x[1]);}
\DoxyCodeLine{  \mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}}[3] = -\/cos(x[0])*exp(x[1]);}
\DoxyCodeLine{  \mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}}[4] = cos(x[0])*exp(x[1]);}
\DoxyCodeLine{  \mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}}[5] = -\/sin(x[0])*exp(x[1]);}
\DoxyCodeLine{ \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Source function required to make the solution above an exact solution }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacePhysical__Variables_ae11027d76c5f512b7db6a1b6d17dc792}{source\_function}}(\textcolor{keyword}{const} Vector<double>\& x, \textcolor{keywordtype}{double}\& source)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  source = 0.0;}
\DoxyCodeLine{ \}}
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{// end of namespace}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysubsection{The driver code}\label{index_main}
The driver code is very simple and short. It is where the problem is defined. In this study, the problem is constructed using the structured mesh with triangular elements in 2D. A number of nodes in an element has to be specific as a template parameter in the problem set up. This is crucial in order to take care of element nodes which we will describe in \href{../../../shell/linear_shell/html/index.html}{\texttt{ another tutorial}}. Following the usual self-\/test, we call the function {\ttfamily Biharmonic\+Problem\+::newton\+\_\+solve()} to compute the solution of the problem. {\ttfamily Biharmonic\+Problem\+::doc\+\_\+solution()} will output the solution afterwards.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======start\_of\_main==================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Driver for 2D Biharmonic problem}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=====================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{structured__2d__biharmonic__bellelement_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set up the problem: }}
\DoxyCodeLine{ \textcolor{comment}{// Solve a 2D Biharmonic problem }}
\DoxyCodeLine{ \mbox{\hyperlink{classMyBiharmonicBellProblem}{MyBiharmonicBellProblem<BiharmonicBellElement<2,2>}},2,2> \textcolor{comment}{//Element type as template parameter}}
\DoxyCodeLine{  problem(\mbox{\hyperlink{namespacePhysical__Variables_ae11027d76c5f512b7db6a1b6d17dc792}{Physical\_Variables::source\_function}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Check whether the problem can be solved}}
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)nProblem self-\/test "};}
\DoxyCodeLine{ \textcolor{keywordflow}{if} (problem.self\_test()==0)  }
\DoxyCodeLine{  \{}
\DoxyCodeLine{   cout << \textcolor{stringliteral}{"passed: Problem can be solved."} << std::endl;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \textcolor{keywordflow}{else} }
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordflow}{throw} OomphLibError(\textcolor{stringliteral}{"failed!"},\textcolor{stringliteral}{"main()"},OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{// Set up doc info}}
\DoxyCodeLine{ DocInfo doc\_info;}
\DoxyCodeLine{ doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});}
\DoxyCodeLine{ doc\_info.number()=0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Solve the problem}}
\DoxyCodeLine{ problem.newton\_solve();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{//Output the solution}}
\DoxyCodeLine{ problem.doc\_solution(doc\_info);}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysubsection{The problem class}\label{index_problem}
The problem class has four member functions, illustrated as follows\+:


\begin{DoxyItemize}
\item The problem constructor
\item {\ttfamily action\+\_\+before\+\_\+newton\+\_\+solve()} \+: Update the problem specifications before solve. Boundary conditions maybe set here.
\item {\ttfamily action\+\_\+after\+\_\+newton\+\_\+solve()} \+: Update the problem specifications after solve.
\item {\ttfamily doc\+\_\+solution()} \+: Pass the number of the case considered, so that output files can be distinguished.
\end{DoxyItemize}From the above mentioned functions, only the problem constructor is non-\/trivial.

In the present problem, the function {\ttfamily Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve()} is not required, so it remains empty. Also, the class includes a private data member which store a pointer to a source function.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_problem\_class============================================}}
\DoxyCodeLine{\textcolor{comment}{/// 2D Biharmonic problem.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keywordtype}{unsigned} DIM, \textcolor{keywordtype}{unsigned} NNODE\_1D> }
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classMyBiharmonicBellProblem}{MyBiharmonicBellProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: Pass number of elements and pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classMyBiharmonicBellProblem_a61b5ab7db1511188dd7ca00e01179dda}{MyBiharmonicBellProblem}}(\textcolor{keyword}{typename} MyBiharmonicEquations<DIM,NNODE\_1D>::SourceFctPt source\_fct\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classMyBiharmonicBellProblem_aa81548287a36375d4e3841cf3d71489b}{\string~MyBiharmonicBellProblem}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keyword}{delete} mesh\_pt();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs before solve: (Re)set boundary conditions}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classMyBiharmonicBellProblem_acdbf06c4f8cf70ee89cd8f1002da98e8}{actions\_before\_newton\_solve}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs after solve (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classMyBiharmonicBellProblem_afbe1effa8e47ff655f99d8ec869eaa2f}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// \(\backslash\)short Doc the solution, pass the number of the case considered,}}
\DoxyCodeLine{\textcolor{comment}{ /// so that output files can be distinguished.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classMyBiharmonicBellProblem_ae361099fb498e9965ea37a648ce71032}{doc\_solution}}(DocInfo\& doc\_info);}
\DoxyCodeLine{ }
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keyword}{typename} MyBiharmonicEquations<DIM,NNODE\_1D>::SourceFctPt \mbox{\hyperlink{classMyBiharmonicBellProblem_ac67539e5f625b52f2da8055599e2c72d}{Source\_fct\_pt}};}
\DoxyCodeLine{ }
\DoxyCodeLine{\}; \textcolor{comment}{// end of problem class}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysubsection{The Problem constructor}\label{index_constructor}
The problem constructor starts by overloading the function {\ttfamily Problem\+::mesh\+\_\+pt()} and set to the specific mesh used in this problem. In this tutorial, we implement the problem with 2D triangular structured mesh which is internally created by {\ttfamily Simple\+Rectangular\+Tri\+Mesh$<$$>$}. The generated output will be used to build {\ttfamily oomph-\/lib} mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_constructor===============================================}}
\DoxyCodeLine{\textcolor{comment}{/// \(\backslash\)short Constructor for 2D Biharmonic problem.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// Discretise the 2D domain with n\_element elements of type ELEMENT.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// Specify function pointer to source function. }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keywordtype}{unsigned} DIM, \textcolor{keywordtype}{unsigned} NNODE\_1D>}
\DoxyCodeLine{\mbox{\hyperlink{classMyBiharmonicBellProblem_a61b5ab7db1511188dd7ca00e01179dda}{MyBiharmonicBellProblem<ELEMENT,DIM,NNODE\_1D>::MyBiharmonicBellProblem}}}
\DoxyCodeLine{(\textcolor{keyword}{typename} MyBiharmonicEquations<DIM,NNODE\_1D>::SourceFctPt source\_fct\_pt) : }
\DoxyCodeLine{ Source\_fct\_pt(source\_fct\_pt)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{ \textcolor{comment}{// Build mesh and store pointer in Problem}}
\DoxyCodeLine{ Problem::mesh\_pt() = \textcolor{keyword}{new} SimpleRectangularTriMesh<ELEMENT>}
\DoxyCodeLine{(\mbox{\hyperlink{namespacePhysical__Variables_ae766d6695cfb9a8d87be9767b38245ff}{Physical\_Variables::n\_x}},\mbox{\hyperlink{namespacePhysical__Variables_a35801b250816fa72ce9023f8738515fa}{Physical\_Variables::n\_y}},\mbox{\hyperlink{namespacePhysical__Variables_af92161eeeab3e15a31698af80f8d09db}{Physical\_Variables::l\_x}},\mbox{\hyperlink{namespacePhysical__Variables_a9f73110ebbfe999c6f09ac797793a537}{Physical\_Variables::l\_y}});}

\end{DoxyCodeInclude}


Next, the boundary conditions of the problem will be taken care. We pin the nodal values on all boundaries and apply the Dirichlet boundary conditions. Note that the boundary identities are labelled anticlockwise where the first boundary is associated with the side $ (x,y) = (0,y). $


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// start\_of\_boundary\_conditions}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_bound = mesh\_pt()-\/>nboundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}=0;\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}<n\_bound;\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} n\_node = mesh\_pt()-\/>nboundary\_node(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}});}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     mesh\_pt()-\/>boundary\_node\_pt(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}},n)-\/>pin(0); }
\DoxyCodeLine{     mesh\_pt()-\/>boundary\_node\_pt(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}},n)-\/>pin(1); }
\DoxyCodeLine{     mesh\_pt()-\/>boundary\_node\_pt(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}},n)-\/>pin(2);}
\DoxyCodeLine{}
\DoxyCodeLine{     mesh\_pt()-\/>boundary\_node\_pt(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}},n)-\/>pin(3);}
\DoxyCodeLine{     mesh\_pt()-\/>boundary\_node\_pt(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}},n)-\/>pin(4);}
\DoxyCodeLine{     mesh\_pt()-\/>boundary\_node\_pt(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}},n)-\/>pin(5);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \textcolor{comment}{// end of boundary conditionss }}

\end{DoxyCodeInclude}


We then loop over the elements and set the pointer to the physical parameters, the function pointer to the source function which is the function on the right-\/hand side of the Biharmonic equation.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Loop over elements and set pointers to Physical parameters}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}=0;\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}<n\_element;\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}}
\DoxyCodeLine{   ELEMENT *elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()-\/>element\_pt(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Set the source function pointer and all physical variables}}
\DoxyCodeLine{   elem\_pt-\/>source\_fct\_pt() = Source\_fct\_pt;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \textcolor{comment}{// end of pointers set up}}

\end{DoxyCodeInclude}


We finish the constructor by assigning the equation numbering scheme. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ assign\_eqn\_numbers();}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of constructor}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
\hypertarget{index_actionbefore}{}\doxysubsection{Action before newton solve}\label{index_actionbefore}
In the {\ttfamily action\+\_\+before\+\_\+newton\+\_\+solve()}, the problem specifications will be updated before performing the newton solve. The boundary values will be (re)set from the exact solutions.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===start\_of\_actions\_before\_newton\_solve========================================}}
\DoxyCodeLine{\textcolor{comment}{/// \(\backslash\)short Update the problem specs before solve: (Re)set boundary values}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// from the exact solution. }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keywordtype}{unsigned} DIM, \textcolor{keywordtype}{unsigned} NNODE\_1D>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classMyBiharmonicBellProblem_acdbf06c4f8cf70ee89cd8f1002da98e8}{MyBiharmonicBellProblem<ELEMENT,DIM,NNODE\_1D>::actions\_before\_newton\_solve}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// How many boundaries are there?}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_bound = mesh\_pt()-\/>nboundary();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{//Loop over the boundaries}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}=0;\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}<n\_bound;\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// How many nodes are there on this boundary?}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} n\_node = mesh\_pt()-\/>nboundary\_node(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}});}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Loop over the nodes on boundary}}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Get pointer to node}}
\DoxyCodeLine{     Node* nod\_pt=mesh\_pt()-\/>boundary\_node\_pt(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}},n);}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Extract nodal coordinates from node:}}
\DoxyCodeLine{     Vector<double> x(2);}
\DoxyCodeLine{     x[0]=nod\_pt-\/>x(0);}
\DoxyCodeLine{     x[1]=nod\_pt-\/>x(1);}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Compute the value of the exact solution at the nodal point}}
\DoxyCodeLine{     Vector<double> \mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}}(6);}
\DoxyCodeLine{     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}=0;\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}<6;\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \mbox{\hyperlink{namespacePhysical__Variables_af90d0c580c57b1152fd1cc7046055031}{Physical\_Variables::get\_exact\_u}}(x,\mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}});}
\DoxyCodeLine{       }
\DoxyCodeLine{       \textcolor{comment}{// Assign the value to the one (and only) nodal value at this node}}
\DoxyCodeLine{       nod\_pt-\/>set\_value(\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}},\mbox{\hyperlink{bell__element_8txt_a9ea9af8920341be9c8d87a284651e90e}{u}}[\mbox{\hyperlink{bell__element_8txt_a7e98b8a17c0aad30ba64d47b74e2a6c1}{i}}]);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\} \textcolor{comment}{// end of actions before solve}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysubsection{Post-\/processing}\label{index_doc}
The post-\/processing routine writes the computed results to an output file.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===start\_of\_doc=========================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Doc the solution in tecplot format. Label files with label.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keywordtype}{unsigned} DIM, \textcolor{keywordtype}{unsigned} NNODE\_1D>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classMyBiharmonicBellProblem_ae361099fb498e9965ea37a648ce71032}{MyBiharmonicBellProblem<ELEMENT,DIM,NNODE\_1D>::doc\_solution}}(DocInfo\& doc\_info)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ ofstream some\_file;}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Number of plot points}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} npts;}
\DoxyCodeLine{ npts=10; }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output solution with specified number of plot points per element}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"\%s/soln\%i.dat"},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ some\_file.precision(20);}
\DoxyCodeLine{ mesh\_pt()-\/>output(some\_file,npts);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output exact solution }}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"\%s/exact\_soln\%i.dat"},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());some\_file.open(filename);}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ mesh\_pt()-\/>output\_fct(some\_file,npts,\mbox{\hyperlink{namespacePhysical__Variables_af90d0c580c57b1152fd1cc7046055031}{Physical\_Variables::get\_exact\_u}}); }
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc pointwise error and compute norm of error and of the solution}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} error,norm;}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"\%s/error\%i.dat"},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ mesh\_pt()-\/>compute\_error(some\_file,\mbox{\hyperlink{namespacePhysical__Variables_af90d0c580c57b1152fd1cc7046055031}{Physical\_Variables::get\_exact\_u}},}
\DoxyCodeLine{                          error,norm); }
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc error norm:}}
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"\(\backslash\)nNorm of error    : "} << sqrt(error) << std::endl; }
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"Norm of solution : "} << sqrt(norm) << std::endl << std::endl;}
\DoxyCodeLine{ cout << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/biharmonic/structured_2d_biharmonic/}{\texttt{ demo\+\_\+drivers/biharmonic/structured\+\_\+2d\+\_\+biharmonic/ }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/biharmonic/structured_2d_biharmonic/structured_2d_biharmonic_bellelement.cc
}{\texttt{ demo\+\_\+drivers/biharmonic/structured\+\_\+2d\+\_\+biharmonic/structured\+\_\+2d\+\_\+biharmonic\+\_\+bellelement.\+cc }} \end{center} 
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
