<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: A two-dimensional Biharmonic problem with the C1-curved triangular finite element</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Get it <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/subversion/html/index.html">Get code from subversion repository</a></li>
            <li><a href="../../../../doc/download/html/index.html">Get code as tar file</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">A two-dimensional Biharmonic problem with the C1-curved triangular finite element </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In <a href="../../../c1_element/bell_element/html/index.html">the previous tutorial</a>, the triangular Bell element has been successfully used to solve the Biharmonic equation which is a fourth-order problem in two dimensions. The domains of interest considered in the particular problem contained only straight boundaries so that this representation was exact. However, in many engineering applications, the geometric boundary of a problem is not straight. Solving such a problem with the straight-sided <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-finite elements limits the convergence rate and accuracy as presented in <a href="http://onlinelibrary.wiley.com/doi/10.1002/pamm.201010272/pdf">a publication of P.Fischer(2010)</a> .</p>
<p>In order to deal with a fourth-order problem, which requires <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-continuity, on a curvilinear domain, the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangular element is introduced in this document. Numerical implementations of the Biharmonic equation on a circular domain will be presented. This is to compare the results obtained between the Bell and the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangular elements. Both rate of convergence and the obtained accuracy will be determined together with the computational time. This is to show that representing a curved boundary by a series of straight-sided elements exhibits a limitation in convergence rate and accuracy. Also, we would like to illustrate that the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangular element can retain the rate of convergence and accuracy when a curvilinear boundary is concerned.</p>
<p>The reader is referred to <a href="../../../c1_element/bell_element/html/index.html">a two-dimensional Biharmonic problem with the Bell triangular finite element tutorial</a> for more detailed descriptions of the variational principle of the Biharmonic equation and the Bell element.</p>
<p>In addition, in this document we demonstrate</p>
<ul>
<li>general descriptions of the <code>C1CurvedElement</code> which is our defined <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-triangular finite element dealing with a 2D curvilinear domain</li>
</ul>
<ul>
<li>numerical results of solving the Biharmonic equation with the <code>C1CurvedElement</code> </li>
</ul>
<p>and</p><ul>
<li>how to implement the <code>C1CurvedElement</code> in <code>oomph-lib</code> using the Biharmonic equation as a case study.</li>
</ul>
<hr  />
<p> <br  />
 </p><hr  />
<h1><a class="anchor" id="overview"></a>
Overview of the C1CurvedElement</h1>
<p>The constructed <code>C1CurvedElement</code> provides a discretisation of a problem with two-dimensional, subparametric triangular finite elements. With this element, the discretisation of the domain of interest in this document will be the union of two sets of triangles. The first set will constitute of straight-sided triangles which is the triangulation of interior elements. The other will constitute of curve-sided triangles which are elements at a curved boundary. Note that each of two distinct triangles of the triangulations is either disjoint, or have a common vertex or a common edge. Consequently, we have to define mappings associated the reference and the physical triangles for each straight and curved triangles.</p>
<p>Regarding the approximation of variables on the straight boundary domain, the Bell shape functions will be employed. On the curved boundary domain, the shape functions will be re-constructed compatible with the Bell shape functions. These new functions will be defined over the approximated domain associated with the mappings approximating the curved boundary. Finally, all of these shape functions will be used to define interpolations of variables on the typical elements.</p>
<p>Specifically, we shall provide</p><ul>
<li>The mappings associated the reference triangle and the physical triangles</li>
<li>The shape functions defined on the <code>C1CurvedElement</code> </li>
<li>The interface of accessible functions to the shape functions</li>
</ul>
<h2><a class="anchor" id="mapping"></a>
The mappings associated the reference triangle with the physical triangles</h2>
<p>In order to approximate the geometry in the <code>C1CurvedElement</code>, the subparametric mapping which associates the reference and the physical triangles is considered in this study. Also, we will define mapping by using polynomials to approximate boundaries.</p>
<p>Since there are two sets of triangular elements in the mesh, different mappings have to be considered for typical elements. Dealing with a straight-sided triangle in a physical domain, an affine mapping will be taken into account. Nonetheless, a nonlinear mapping has to be considered in order to deal with a curved-edge triangle.</p>
<p>Regarding a straight-sided triangle, we define the affine mapping <img class="formulaInl" alt="$F_{K_{I}}$" src="form_1.png"/> which is parametrised by the reference coordinates <img class="formulaInl" alt="$ \hat{x}_{\alpha}, \alpha = 1,2, $" src="form_2.png"/> defined on the reference triangle <img class="formulaInl" alt="$ \hat{K} = \{(\hat{x}_1, \hat{x}_2) | 0 \leq \hat{x}_1, \hat{x}_2 \leq 1, \hat{x}_1 + \hat{x}_2 = 1 \} $" src="form_3.png"/> and can be constructed as follow</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{\alpha} = F_{K_{I\alpha}}(\hat{x}_{1},\hat{x}_{2}) = x_{\alpha 3} + (x_{\alpha 1} - x_{\alpha 3})\hat{x}_{1} + (x_{\alpha 2} - x_{\alpha 3})\hat{x}_{2}, \ \ \ \ \ \ (1) \]" src="form_4.png"/>
</p>
<p> where <img class="formulaInl" alt="$ x_{\alpha i}$" src="form_5.png"/> denote the global coordinates <img class="formulaInl" alt="$ \alpha = 1,2 $" src="form_6.png"/> of the vertices <img class="formulaInl" alt="$\mathbf{a}_{i}, i = 1,2,3,$" src="form_7.png"/> of the physical triangle <img class="formulaInl" alt="$ K_I $" src="form_8.png"/> as depicted in the following figure. Also, <img class="formulaInl" alt="$ F_{K_{I \alpha}} $" src="form_9.png"/> is a <img class="formulaInl" alt="$ \alpha^{th} $" src="form_10.png"/> component of the mapping <img class="formulaInl" alt="$ F_{K_{I}} $" src="form_11.png"/>. This mapping will help us to associate a position <img class="formulaInl" alt="$(\hat{x}_1,\hat{x}_2)$" src="form_12.png"/> on the reference triangle with a position <img class="formulaInl" alt="$(x_{1},x_{2})$" src="form_13.png"/> on the physical triangle whose sides are straight.</p>
<div class="image">
<img src="mapping.gif" alt=""/>
<div class="caption">
A graphical description of the mappings associated between the reference coordinates and the physical coordinates. </div></div>
 <p>Regarding the curved boundary, the mapping <img class="formulaInl" alt="$ F_{K_{C}} $" src="form_14.png"/> is defined to associate between the reference and the physical curved triangles. These curved triangles are considered to have two straight sides and one curved side approximating an arc of the boundary. In this case, the mapping <img class="formulaInl" alt="$ F_{K_{C}} $" src="form_14.png"/> is nonlinear and can be constructed as in the following descriptions.</p>
<p>Let <img class="formulaInl" alt="$\Omega$" src="form_15.png"/> be a given bounded domain on the plane whose boundary is curve in two-dimensional space. We assume that the curved boundary <img class="formulaInl" alt="$\Gamma$" src="form_16.png"/> can be subdivided into a finite number of arcs and each of them can be described as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{1} = \chi_{1}(s), \ \ \ x_{2} = \chi_{2}(s), \ \ \ s_{m} \leq s \leq s_{M}, \]" src="form_17.png"/>
</p>
<p>where <img class="formulaInl" alt="$ x_{\alpha}, \alpha=1,2, $" src="form_18.png"/> denote coordinates in two-dimensional space defined on the curved boundary <img class="formulaInl" alt="$ \Gamma $" src="form_19.png"/> and approximated by the polynomials <img class="formulaInl" alt="$\chi_{1}(s), \chi_{2}(s)$" src="form_20.png"/> which are continuous on the arc <img class="formulaInl" alt="$ [s_{m},s_{M}]. $" src="form_21.png"/></p>
<p>Before we will consider the nonlinear mapping <img class="formulaInl" alt="$ F_{K_{C}} $" src="form_14.png"/>, we will first determine a mapping <img class="formulaInl" alt="$ \varphi_{\alpha} $" src="form_22.png"/> which associates the side <img class="formulaInl" alt="$ \bf{\hat{a}}_1\bf{\hat{a}}_2 $" src="form_23.png"/> on the reference triangle, <img class="formulaInl" alt="$ \hat{K} $" src="form_24.png"/>, with the curved boundary <img class="formulaInl" alt="$\Gamma$" src="form_16.png"/>. This mapping is defined to be parametrised by the reference coordinate, say <img class="formulaInl" alt="$ \hat{x}_{2}, $" src="form_25.png"/> and satisfies</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \varphi_{\alpha}(\hat{x}_2 = 0) = \chi_{\alpha}(s_{m}) = x_{\alpha 1} = \mathbf{a}_{1}, \]" src="form_26.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \varphi_{\alpha}(\hat{x}_2 = 1) = \chi_{\alpha}(s_{M}) = x_{\alpha 2} = \mathbf{a}_{2}, \ \ \ \ \ \ (2) \]" src="form_27.png"/>
</p>
<p>where <img class="formulaInl" alt="$ \varphi_{\alpha}(\hat{x_{2}}) \equiv \chi_{\alpha}(s_{m} + (s_{M}-s_{m})\hat{x}_{2}) $" src="form_28.png"/>. Note that either the reference coordinate <img class="formulaInl" alt="$ \hat{x}_{1} $" src="form_29.png"/> or <img class="formulaInl" alt="$ \hat{x}_{2} $" src="form_30.png"/> can be used to parametrise the arc but re-calculation will be required to defined the mapping.</p>
<p>Here, the Hermite-type polynomial of degree 3 is our choice to approximate the curved boundary. The reason for this choice is that cubic is the minimum degree of polynomial to obtain the <img class="formulaInl" alt="$C^1$" src="form_31.png"/>-continuity ( see <a href="http://www.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=271868&amp;_user=6991156&amp;_pii=004578259390111A&amp;_check=y&amp;_origin=article&amp;_zone=toolbar&amp;_coverDate=31-Jan-1993&amp;view=c&amp;originContentFamily=serial&amp;wchp=dGLzVlV-zSkzk&amp;md5=d038a1aec18c25806e39c26187c2a200&amp;pid=1-s2.0-004578259390111A-main.pdf">M.Bernadou (1993)</a> ). Hence, the following four conditions have to be specified</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{\alpha 1} = \varphi_{\alpha}(0) = \chi_{\alpha}(s_{m}), \mbox{ } x_{\alpha 2} = \varphi_{\alpha}(1) = \chi_{\alpha}(s_{M}), \]" src="form_32.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \varphi^{\prime}_{\alpha}(0) = (s_{M}-s_{m})\chi^{\prime}_{\alpha}(s_{m}), \mbox{ } \varphi^{\prime}_{\alpha}(1) = (s_{M}-s_{m})\chi^{\prime}_{\alpha}(s_{M}). \ \ \ \ (3)\]" src="form_33.png"/>
</p>
<p>These conditions are constraints in order to satisfy (2) for the coordinate values <img class="formulaInl" alt="$ x_{\alpha} $" src="form_34.png"/> in order to obtain the continuity.</p>
<p>By considering the cubic polynomial, <img class="formulaInl" alt="$ \varphi_{\alpha}(\hat{x}_2) $" src="form_35.png"/>, in the form of (4) with the conditions for derivatives in (3), the mapping <img class="formulaInl" alt="$ \varphi_{\alpha}(\hat{x}_2) $" src="form_35.png"/> can be obtained.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \varphi_{\alpha}(\hat{x}_2) = x_{\alpha 1} + (x_{\alpha 2} - x_{\alpha 1})\hat{x}_{2} + \hat{x}_{2}(1-\hat{x}_{2})[m_{\alpha}\hat{x}_{2}+c_{\alpha}]. \ \ \ \ (4) \]" src="form_36.png"/>
</p>
<p>Regarding the nonlinear mapping <img class="formulaInl" alt="$ F_{K_{C}}, $" src="form_37.png"/> it is defined to approximate the coordinates <img class="formulaInl" alt="$ x_{\alpha}, \alpha = 1,2, $" src="form_38.png"/> so that the side <img class="formulaInl" alt="$ \bf{\hat{a}}_1\bf{\hat{a}}_2 $" src="form_23.png"/> on the reference triangle, <img class="formulaInl" alt="$ \hat{K}, $" src="form_39.png"/> associates with the curved side of the curved physical triangle. Also, the mapping <img class="formulaInl" alt="$ F_{K_{C}} $" src="form_14.png"/> has to be an affine mapping along the side <img class="formulaInl" alt="$ \mathbf{a}_{3}\mathbf{a}_{\alpha}, \alpha = 1,2 $" src="form_40.png"/>. Therefore, the nonlinear mapping <img class="formulaInl" alt="$ F_{K_{C}} $" src="form_14.png"/> that associates the reference and the curved elements with the cubic polynomial approximating a curved boundary is obtained as follow</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{\alpha} = F_{K_{C\alpha}}(\hat{x}_{1},\hat{x}_{2}) = x_{\alpha 3} + ( x_{\alpha 1} - x_{\alpha 3} )\hat{x}_{1} + (x_{\alpha 2} - x_{\alpha 3})\hat{x}_{2} \]" src="form_41.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ + \frac{1}{2}\hat{x}_{1}\hat{x}_{2}\left\{\left[2(x_{\alpha 2}-x_{\alpha 1})-(s_{M}-s_{m})(\chi^{\prime}_{\alpha}(s_{m}) +\chi^{\prime}_{\alpha}(s_{M}))\right](\hat{x}_{2}-\hat{x}_{1} ) + (s_{M}-s_{m})\left[\chi^{\prime}_{\alpha}(s_{m}) -\chi^{\prime}_{\alpha}(s_{M})\right]\right\}, \ \ \ (5)\]" src="form_42.png"/>
</p>
<p> where <img class="formulaInl" alt="$ F_{K_{C\alpha}} $" src="form_43.png"/> denotes an <img class="formulaInl" alt="$\alpha^{th} $" src="form_44.png"/> component of the mapping <img class="formulaInl" alt="$ F_{K_{C}} $" src="form_14.png"/>. Note that the nonlinear mapping <img class="formulaInl" alt="$ F_{K_{C\alpha}}(1-\hat{x}_{2},\hat{x}_{2}) = \varphi_{\alpha}(\hat{x}_{2}) $" src="form_45.png"/> when comes to the side <img class="formulaInl" alt="$ \mathbf{a}_{1}\mathbf{a}_{2} $" src="form_46.png"/>, as decided.</p>
<p>The derivation of the nonlinear mapping <img class="formulaInl" alt="$ F_{K_{C}} $" src="form_14.png"/> can be found in <a href="http://www.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=271868&amp;_user=6991156&amp;_pii=004578259390111A&amp;_check=y&amp;_origin=article&amp;_zone=toolbar&amp;_coverDate=31-Jan-1993&amp;view=c&amp;originContentFamily=serial&amp;wchp=dGLzVlV-zSkzk&amp;md5=d038a1aec18c25806e39c26187c2a200&amp;pid=1-s2.0-004578259390111A-main.pdf">a publication of M.Bernadou (1993)</a> .</p>
<hr  />
<h2><a class="anchor" id="c1_shape"></a>
The shape functions defined on the C1CurvedElement</h2>
<p>In this section, we will elaborate the shape functions defined on the <code>C1CurvedElement</code>. Since there are two types of elements defined on the <code>C1CurvedElement</code>, two sets of shape functions will be considered.</p>
<p>On the straight-sided triangular element, we inherit the <code>BellElement</code> to approximate values defined on the element. Therefore, the Bell shape functions will be employed and their details can be found in <a href="../../../c1_element/bell_element/html/index.html">the Bell triangular finite element tutorial</a>. Note that the Bell shape functions are defined with respect to the global coordinates so that the transformation of derivatives between the local and the global coordinates is no longer need in an implementation.</p>
<p>Next, we will define shape functions of the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved finite element in order to interpolate any function defined over the curve-sided triangular element. Unlike the interpolation functions defined on the Bell triangular element, the interpolation functions of the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangle are chosen to defined over the reference triangle <img class="formulaInl" alt="$ \hat{K}. $" src="form_47.png"/> Therefore, for any polynomial <img class="formulaInl" alt="$p \in P_{K}$" src="form_48.png"/> defined over the curved triangle <img class="formulaInl" alt="$ K_{C}, $" src="form_49.png"/> we employ the mapping defined in (5) to associate this polynomial <img class="formulaInl" alt="$ p $" src="form_50.png"/> with the polynomial defined on the reference triangle as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat{p} = p \circ F_{K_C}. \]" src="form_51.png"/>
</p>
<p>Note that defining a polynomial on the reference triangle, <img class="formulaInl" alt="$\hat{K}$" src="form_52.png"/>, is a desirable condition which is convenient for the study of the approximation error and to take into account the numerical integration.</p>
<p>Subsequently, using a polynomial of degree 3 to approximate a curved boundary in our study, polynomials of degree 7 have to be defined as shape functions over the reference triangle in order to interpolate unknowns on a curved triangle. This is in order to achieve the required convergence and to satisfy the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-compatibility with the Bell finite elements. The reader may refer to <a href="http://www.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=271868&amp;_user=6991156&amp;_pii=004578259390111A&amp;_check=y&amp;_origin=article&amp;_zone=toolbar&amp;_coverDate=31-Jan-1993&amp;view=c&amp;originContentFamily=serial&amp;wchp=dGLzVlV-zSkzk&amp;md5=d038a1aec18c25806e39c26187c2a200&amp;pid=1-s2.0-004578259390111A-main.pdf">a publication of M.Bernadou (1993)</a> for more details.</p>
<p>The desired <img class="formulaInl" alt="$P_{7}$" src="form_53.png"/>- <img class="formulaInl" alt="$C^1$" src="form_31.png"/> reference element will constitute of <img class="formulaInl" alt="$\hat{K}$" src="form_52.png"/> which is a unit right-angled triangle, the set of degrees of freedom <img class="formulaInl" alt="$ \hat{\Sigma}(\hat{w}),$" src="form_54.png"/> and <img class="formulaInl" alt="$\hat{P}$" src="form_55.png"/> which is a space of complete polynomials of degree 7 with its dimension equals to 36. The set of <img class="formulaInl" alt="$ \hat{\Sigma}(\hat{w}) $" src="form_56.png"/> composes of values and their derivatives defined on vertices, <img class="formulaInl" alt="$ \mathbf{\hat{a}}_i, i=1,2,3, $" src="form_57.png"/> and along edges, <img class="formulaInl" alt="$ \mathbf{\hat{b}}_i, i=1,2,3 $" src="form_58.png"/>, <img class="formulaInl" alt="$ \mathbf{\hat{d}}_i, i = 1,...,6, $" src="form_59.png"/> and the internal nodes, <img class="formulaInl" alt="$ \mathbf{\hat{e}}_i, i=1,2,3, $" src="form_60.png"/> of the reference triangle illustrated in the following figure and are defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat{\Sigma}(\hat{w}) = \left\{\hat{w}(\mathbf{\hat{a}}_{i}), \frac{\partial \hat{w}}{\partial \hat{x}_{1}}(\mathbf{\hat{a}}_{i}), \frac{\partial \hat{w}}{\partial \hat{x}_{2}}(\mathbf{\hat{a}}_{i}), \frac{\partial^2 \hat{w}}{\partial \hat{x}^2_{1}}(\mathbf{\hat{a}_{i}}), \frac{\partial^2 \hat{w}}{\partial \hat{x}_{1}\hat{x}_{2}}(\mathbf{\hat{a}}_{i}), \frac{\partial^2 \hat{w}}{\partial \hat{x}^2_{2}}(\mathbf{\hat{a}}_{i}), i=1,2,3 \right\} \]" src="form_61.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \cup \left\{ -\frac{\partial \hat{w}}{\partial \hat{x}_{1}}(\mathbf{\hat{b}}_{1}); -\frac{\partial \hat{w}}{\partial \hat{x}_{2}}(\mathbf{\hat{b}}_{2}); \frac{\sqrt{2}}{2}\left(\frac{\partial \hat{w}}{\partial \hat{x}_{1}}+\frac{\partial \hat{w}}{\partial \hat{x}_{2}}\right)(\mathbf{\hat{b}}_{3}) \right\} \cup \]" src="form_62.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left\{ \hat{w}(\mathbf{\hat{d}}_{i}),i=1,...,6; -\frac{\partial \hat{w}}{\partial \hat{x}_{1}}(\mathbf{\hat{d}}_{i}), i=1,2; -\frac{\partial \hat{w}}{\partial \hat{x}_{2}}(\mathbf{\hat{d}}_{i}), i=3,4; \frac{\sqrt{2}}{2}\left(\frac{\partial \hat{w}}{\partial \hat{x}_{1}} + \frac{\partial \hat{w}}{\partial \hat{x}_{2}}\right)(\mathbf{\hat{d}}_{i}), i=5,6 \right\} \]" src="form_63.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \cup \left\{ \hat{w}(\mathbf{\hat{e}}_{i}),i=1,2,3 \right\}, \]" src="form_64.png"/>
</p>
<p>where <img class="formulaInl" alt="$\hat{w}$" src="form_65.png"/> denotes a function defined over the reference element <img class="formulaInl" alt="$\hat{K}.$" src="form_66.png"/></p>
<div class="image">
<img src="Triple_of_FE.gif" alt=""/>
<div class="caption">
The reference element of the C1-curved finite element compatible with the Bell triangle where the degree of polynomial approximating curved boundaries is cubic. </div></div>
 <p>Since the <img class="formulaInl" alt="$ P_7-C^1 $" src="form_67.png"/>-shape functions of the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved finite element are defined on the reference triangle <img class="formulaInl" alt="$ \hat{K} $" src="form_24.png"/>, its 36 degrees of freedom have to be associated with those defined on the curved physical triangle. To consider the degrees of freedom defined on the curved physical triangle, they have to ensure the connection of class <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-compatible with the Bell triangles as the Bell triangles are its adjacent elements.</p>
<p>To define such a connection, the following conditions have to be satisfied to assure a compatibility between a curved finite element and the Bell triangle.</p>
<ul>
<li>One-variable polynomials of any function <img class="formulaInl" alt="$ p $" src="form_50.png"/> defined over the curved triangle and their normal derivatives <img class="formulaInl" alt="$ \frac{\partial p}{\partial n} $" src="form_68.png"/> along the connected sides have to coincide with those of the Bell elements. That is the degrees of the polynomial and its normal derivatives along the connecting sides have to be of degree 5 and 3, respectively.</li>
<li>the degrees of freedom of the curved finite element relative to the connecting sides have to be identical to those of the Bell elements and have to be entirely determined on those sides.</li>
</ul>
<p>Therefore, we have that our <img class="formulaInl" alt="$ C^1$" src="form_69.png"/>-curved triangular finite element has to define so that the set of degrees of freedom on the vertices of the curved physical triangle is the same as those of the Bell element.</p>
<p>Furthermore, there will be three additional degrees of freedom defined inside the curved triangle <img class="formulaInl" alt="$ K_C$" src="form_70.png"/> as seen in Fig. 1.3. These nodes come from three internal nodes defined in order to ensure the <img class="formulaInl" alt="$C^1$" src="form_31.png"/>-continuity in determining the polynomial of degree 7 on the reference element. Consequently, there are 21 degrees of freedom in total defined over the curved triangular element.</p>
<p>The set <img class="formulaInl" alt="$\Sigma_{K}(v)$" src="form_71.png"/> of values of degrees of freedom of <img class="formulaInl" alt="$v$" src="form_72.png"/> defined on the curved physical triangle is then given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Sigma_{K}(v) = \left\{ (D^{\alpha}v(\mathbf{a}_{i}), \alpha = 0,1,2), i=1,2,3; v(\mathbf{e}_{i}), i = 1,2,3 \right\}. \ \ \ \ \ \ (6)\]" src="form_73.png"/>
</p>
<div class="image">
<img src="Set_of_dof_curved_element.gif" alt=""/>
<div class="caption">
The set of degrees of freedom for the C1-curved finite element compatible with the Bell element. </div></div>
 <p>In order to interpolate a function <img class="formulaInl" alt="$ v $" src="form_74.png"/> defined on the curved physical triangle, the <img class="formulaInl" alt="$P_7-C^1$" src="form_75.png"/>-shape functions and the 36 associated values of degrees of freedom have to be taken into account. Since the 36 nodal degrees of freedom depend on 21 nodal degrees of freedom defined on <img class="formulaInl" alt="$K_C$" src="form_76.png"/> illustrated in (6), the association between those values of degrees of freedom have to be defined.</p>
<p>Since the number of degrees of freedom defined on the curved and the reference triangles are different, the derivation of the associations is not straightforward. Detailed descriptions of the derivation of the association <img class="formulaInl" alt="$ \tilde{M} $" src="form_77.png"/> can be found in <a href="http://www.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=271868&amp;_user=6991156&amp;_pii=004578259390111A&amp;_check=y&amp;_origin=article&amp;_zone=toolbar&amp;_coverDate=31-Jan-1993&amp;view=c&amp;originContentFamily=serial&amp;wchp=dGLzVlV-zSkzk&amp;md5=d038a1aec18c25806e39c26187c2a200&amp;pid=1-s2.0-004578259390111A-main.pdf">a publication of M.Bernadou (1993)</a>.</p>
<hr  />
<h2><a class="anchor" id="intp"></a>
The interpolation of a function, v, defined on the domain</h2>
<p>The interpolation of a function <img class="formulaInl" alt="$ v $" src="form_74.png"/> defined on the physical triangle can be determined associated with the straight and the curved element.</p>
<p>If we want to interpolate a function <img class="formulaInl" alt="$ v $" src="form_74.png"/> defined on the straight physical triangle, the Bell shape functions have to be taken into account. Therefore, the interpolation can be defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ u(x_1,x_2) = \sum_{l=1}^{3}\sum_{k=1}^{6} u_{lk}\psi^{B}_{lk}(x_{1},x_{2}), \ \ \ \ \ \ (7) \]" src="form_78.png"/>
</p>
<p>where <img class="formulaInl" alt="$ u_{lk} $" src="form_79.png"/> and <img class="formulaInl" alt="$ \psi^{B}_{lk}, l=1,2,3, k=1,...,6, $" src="form_80.png"/> are the nodal values and the Bell shape functions defined on the physical element <img class="formulaInl" alt="$ K_I $" src="form_8.png"/>, respectively.</p>
<p>Otherwise, the interpolation of a function <img class="formulaInl" alt="$ v $" src="form_74.png"/> defined on the curved physical triangle can be determined by quantities defined on the reference triangle as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ u(x_1(\mathbf{\xi}),x_2(\mathbf{\xi})) = \sum_{j=1}^{36}{\hat{u}_{j}\hat{\psi}_{j}}(\xi_{1},\xi_{2}), \ \ \ \ \ \ (8)\]" src="form_81.png"/>
</p>
<p>where <img class="formulaInl" alt="$ \hat{u}_{j} $" src="form_82.png"/> are the nodal values defined at node <img class="formulaInl" alt="$j$" src="form_83.png"/> on the reference triangle <img class="formulaInl" alt="$ \hat{K} $" src="form_24.png"/>. Also, <img class="formulaInl" alt="$ \hat{\psi}_{j}, j=1,...,36, $" src="form_84.png"/> are the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-shape functions defined by complete polynomials of degree 7 on the reference element <img class="formulaInl" alt="$ \hat{K} $" src="form_24.png"/>.</p>
<p>Since all these nodal values <img class="formulaInl" alt="$ \hat{u}_{j} $" src="form_82.png"/> are defined to depend only on 21 nodal values, <img class="formulaInl" alt="$ u_{k} $" src="form_85.png"/>, defined on the curved element <img class="formulaInl" alt="$ K_{C} $" src="form_86.png"/>, the set of nodal values defined on the reference element can be associated with those defined on the curved element through the association <img class="formulaInl" alt="$ \tilde{M} $" src="form_77.png"/> by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat{u}_{j} = \sum_{k=1}^{21}{u_{k}\tilde{M}_{kj}}, \forall j=1,...,36, \ \ \ \ \ \ (9) \]" src="form_87.png"/>
</p>
<p>Substituting (9) into (8), we have that the approximation of the unknown <img class="formulaInl" alt="$ u$" src="form_88.png"/> can be expressed as the linear combination between the shape functions defined on the reference triangle <img class="formulaInl" alt="$ \hat{K} $" src="form_24.png"/> and the values defined on the physical curved triangle as follow</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ u(x_1(\mathbf{\xi}),x_2(\mathbf{\xi})) = \sum_{j=1}^{36}{\sum_{k=1}^{21}{u_{k}\tilde{M}_{kj}}\hat{\psi}_{j}}(\xi_{1},\xi_{2}). \]" src="form_89.png"/>
</p>
<p>Note that the shape functions of the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved element can be determined from the <img class="formulaInl" alt="$ \delta_{ij} $" src="form_90.png"/> property of the shape function. Also, they are defined with respect to the local coordinates. Hence, the transformation of derivatives between the local and the global coordinates is needed in an implementation in order to ensure <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-continuity.</p>
<hr  />
<h2><a class="anchor" id="interface"></a>
The interface of accessible functions to the shape functions of the C1CurvedElement</h2>
<p>Regarding the curvilinear boundary domain study in this tutorial, its triangulation constitutes of both straight-sided and curve-sided triangle. Different number of nodes and shape functions have to be considers in <code>C1CurvedElement</code> in order to associate with both the straight and curved triangular elements in the triangulation.</p>
<p>Now, we will consider the face-element of the <code>C1CurvedElement</code>. According to section 1.1.2, we have that 21 degrees of freedom defined on the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangular element are associated with three vertices and three interior node of the curved physical triangle. Unlike the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangular elements, all 18 degrees of freedom of the Bell element are defined on only three vertices.</p>
<p>Therefore, the face element of the <code>C1CurvedElement</code> have to define generally in order to associate with both straight-sided and curve-sided elements. Consequencely, there are six nodes in total in a <code>C1CurvedElement</code> with <code>NNODE_1D</code> equals to 2. The following figure illustrates the number of nodes defined in both the Bell and the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangular elements.</p>
<div class="image">
<img src="Graphic_curved_element.gif" alt=""/>
<div class="caption">
The graphical description of the face-element defined in the <code>C1CurvedElement</code>. </div></div>
 <p>Apparently, our constructed <code>C1CurvedElement</code> are only available for three interior nodes for all cases of <code>NNODE_1D</code>. The fixed number of interior nodes is a consequence of using degree 3 of polynomial to approximate a curvilinear boundary as mentioned in subsection 1.1.1.</p>
<p>In order to approximate the geometry, the linear mapping defined in (1) is employed to associate with the straight-sided triangles while the nonlinear mapping defined in (5) is employed to associate with the curved triangles. Those mapping will be inherited from GeometricCurvedTElementShape&lt;2&gt; and can be accessible in <code>C1CurvedElemet&lt;&gt;</code> by</p>
<center> <table class="doxtable">
<tr>
<td><center> <code>C1CurvedElement&lt;&gt;::shape(s,x)</code>, </center>   </td></tr>
</table>
</center><p>Note that, unlike other elements in <code>oomph-lib</code>, the geometric shape functions in <code>C1CurvedElement</code> rather computed the global position of the local coordinate <img class="formulaInl" alt="$ s. $" src="form_91.png"/></p>
<p>Regarding shape functions defined on the <code>C1CurvedElement</code>, different definitions of shape functions are defined in order to associate with both straight and curved triangular elements. On the set of straight-sided triangles, the Bell shape functions will be employed to approximate the unknowns. When the curve-sided triangles are concerned, the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangular shape functions defined in subsection 1.1.2 will be used to approximate the unknowns. Hence, the <code>C1CurvedElement</code> is a <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-triangular element carries two families of <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-shape functions defined on both straight and curved triangles.</p>
<p>The shape functions of both Bell and <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved triangular elements can be accessible via <code>BellElementShape::Bshape(...)</code> and <code>C1CurvedElementShape::Cshape(...)</code>, respectively. These functions will compute the shape functions at local coordinate <img class="formulaInl" alt="$ s. $" src="form_91.png"/></p>
<p>As the global coordinates are required in the derivation of the shape functions of the <code>BellElementShape&lt;&gt;</code>, the physical coordinates of vertices have to be passed as an argument when shape functions are overloaded. The interface of the Bell shape functions obtained from <code>BellElementShape&lt;&gt;</code> at local coordinate <img class="formulaInl" alt="$ s $" src="form_92.png"/> is <code>BellElementShape&lt;&gt;::Bshape(s,psi,position)</code>. Similarly, the first and the second-order derivatives can be obtained at local coordinate <img class="formulaInl" alt="$ s $" src="form_92.png"/> as <code>BellElementShape&lt;&gt;::dBshape(s,psi,dpsi,position)</code> and <code>BellElementShape&lt;&gt;::d2Bshape(s,psi,dpsi,d2psi,position)</code>, respectively. The vector <code>position</code> is the collection of coordinates on vertices of straight-edged triangles.</p>
<p>Now, to obtained the basis functions that employed to approximate variables on the straight-sided triangles in <code>C1CurvedElement</code>, they can be accessible via</p>
<center> <table class="doxtable">
<tr>
<td><center> <code>C1CurvedElement&lt;&gt;::basis_straight(s,psi)</code>, </center>   </td></tr>
</table>
</center><p>Furthermore, the first- and second-order derivatives of the Bell shape functions in <code>C1CurvedElement&lt;&gt;</code> can be accessible via</p>
<center> <table class="doxtable">
<tr>
<td><center> <code>C1CurvedElement&lt;&gt;::dbasis_straight(s,psi,dpsi)</code>, </center>   </td></tr>
</table>
</center><p>and</p>
<center> <table class="doxtable">
<tr>
<td><center> <code>C1CurvedElement&lt;&gt;::d2basis_straight(s,psi,dpsi,d2psi)</code>, </center>   </td></tr>
</table>
</center><p> respectively.</p>
<p>Unlike the Bell shape functions, the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved shape functions has a usual interface as no global coordinate is required. They can be overloaded from <code>C1CurvedElementShape&lt;&gt;::Cshape(s,psi)</code> while their first- and second-order derivatives can be obtained from <code>C1CurvedElementShape&lt;&gt;::dCshape(s,psi,dpsi)</code> and <code>C1CurvedElementShape&lt;&gt;::d2Cshape(s,psi,dpsi,d2psi)</code>, respectively.</p>
<p>Now, to obtained the basis functions that employed to approximate variables on the curved triangles in <code>C1CurvedElement</code>, they can be accessible via</p>
<center> <table class="doxtable">
<tr>
<td><center> <code>C1CurvedElement&lt;&gt;::basis_curve(s,psi)</code>, </center>   </td></tr>
</table>
</center><p>Furthermore, the first- and second-order derivatives of the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-curved shape functions in <code>C1CurvedElement</code> can be accessible via</p>
<center> <table class="doxtable">
<tr>
<td><center> <code>C1CurvedElement&lt;&gt;::dbasis_curve(s,psi,dpsi)</code>, </center>   </td></tr>
</table>
</center><p>and</p>
<center> <table class="doxtable">
<tr>
<td><center> <code>C1CurvedElement&lt;&gt;::d2basis_curve(s,psi,dpsi,d2psi)</code>, </center>   </td></tr>
</table>
</center><p> respectively.</p>
<p>Regarding the association, which associated the values of degrees of freedom between the reference and physical curved triangles, mentioned in (9), it can be inherited from the functions <code>C1CurvedElementShape&lt;2&gt;::set_of_value(D,B,node_position,bd_element,bd_node_position,x)</code> and the following are required as its arguments</p>
<ul>
<li>coordinates of three vertices of a curved triangle passed as <code>node_position</code>,</li>
<li>coordinates of the vertices of a curved triangle that situate on a curved boundary passed as <code>bd_node_position</code>,</li>
<li>coordinates of the vertices of a curved triangle that is off-boundary passed as <code>x</code>.</li>
</ul>
<p>Note that the matrices <img class="formulaInl" alt="$ D, B $" src="form_93.png"/> denote the submatrices of value transformation described in <a href="http://www.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=271868&amp;_user=6991156&amp;_pii=004578259390111A&amp;_check=y&amp;_origin=article&amp;_zone=toolbar&amp;_coverDate=31-Jan-1993&amp;view=c&amp;originContentFamily=serial&amp;wchp=dGLzVlV-zSkzk&amp;md5=d038a1aec18c25806e39c26187c2a200&amp;pid=1-s2.0-004578259390111A-main.pdf">a publication of M.Bernadou (1993)</a> .</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="reslt"></a>
Solving the Biharmonic equation with the C1CurvedElement</h1>
<p>The sections below provide an example of solving the fourth-order problem using <code>C1CurvedElement</code>. The fourth-order problem consider here is the same Biharmonic equation described in <a href="../../../c1_element/bell_element/html/index.html">another tutorial</a> which is expressed as follow:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial^4 u}{\partial x^4} + 2\frac{\partial^4 u}{\partial x^2\partial y^2} + \frac{\partial^4 u}{\partial y^4} = 0, \ \ \ (10) \]" src="form_94.png"/>
</p>
<p>with the exact solution <img class="formulaInl" alt="$ u(x,y) = \cos(x)e^y.$" src="form_95.png"/> However, in this document, the problem is implemented in the quarter of the unit circular domain <img class="formulaInl" alt="$ \Omega = \{(x,y) | x,y \in [0,1] , x^2+y^2 = 1\} $" src="form_96.png"/> which is a curvilinear boundary domain rather than a straight-sided boundary domain. Similarly, we also apply Dirichlet boundary conditions such that the exact solution is satisfied. Also, the conditions that have to be specified on the boundaries have to correspond with the degrees of freedom defined for the <code>C1CurvedElement</code> in the previous section.</p>
<p>Since 36 values of degrees of freedom defined on the reference triangle depend on the 21 values of degrees of freedom defined on the physical curved triangle, those 21 degrees of freedom on the physical curved triangle have to be imposed. These degrees of freedom constitute of 6 degrees of freedom at 3 vertex nodes and the values of degrees of freedom at 3 internal nodes. The 6 degrees of freedom defined on vertices incorporate the value of unknown field, the first derivatives with respect to the first and second coordinates, and the second derivatives with respect to the first, second, and mix derivatives have to be determined at the boundaries. The boundary specifications can be determined the same as described in <a href="../../../c1_element/bell_element/html/index.html">a two-dimensional Biharmonic problem with the Bell triangular finite element tutorial</a>.</p>
<p>Here are two tables comparing the performance with the associated computational time between the <code>BellElement</code> and the <code>C1CurvedElement</code>. The accuracy of the solutions will base on the <img class="formulaInl" alt="$ L^2 $" src="form_97.png"/>-norm error which is mathematically described as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ |u_{exact}-u_{FE}| = \left( \int_{\Omega} | u_{exact} - u_{FE}|^2 d\Omega \right)^{1/2}, \]" src="form_98.png"/>
</p>
<p> where <img class="formulaInl" alt="$ u_{exact},u_{FE} $" src="form_99.png"/> denote the exact and the finite element solutions, respectively.</p>
<p>Table 1: <img class="formulaInl" alt="$L^2$" src="form_100.png"/>-norm error of the solution obtained from the Biharmonic implementations using the BellElement with various numbers of elements.</p>
<center> <table class="doxtable">
<tr>
<td>Number of elements  </td><td>Number of dofs  </td><td>Error  </td><td>Time (sec)   </td></tr>
<tr>
<td>29  </td><td>48  </td><td><img class="formulaInl" alt="$ 5.67891 \times 10^{-4} $" src="form_101.png"/>  </td><td>0.23   </td></tr>
<tr>
<td>84  </td><td>198  </td><td><img class="formulaInl" alt="$ 1.77260 \times 10^{-4} $" src="form_102.png"/>  </td><td>0.66   </td></tr>
<tr>
<td>250  </td><td>636  </td><td><img class="formulaInl" alt="$ 9.42737 \times 10^{-5} $" src="form_103.png"/>  </td><td>2.02   </td></tr>
<tr>
<td>2034  </td><td>5838  </td><td><img class="formulaInl" alt="$ 3.49306 \times 10^{-5} $" src="form_104.png"/>  </td><td>17.48   </td></tr>
<tr>
<td>4833  </td><td>14022  </td><td><img class="formulaInl" alt="$ 5.12128 \times 10^{-6} $" src="form_105.png"/>  </td><td>43.94     </td></tr>
</table>
<br  />
 </center><p>Table 2: <img class="formulaInl" alt="$L^2$" src="form_100.png"/>-norm error of the solution obtained from the Biharmonic implementations using the C1CurvedElement with various numbers of elements.</p>
<center> <table class="doxtable">
<tr>
<td>Number of elements  </td><td>Number of dofs  </td><td>Error  </td><td>Time (sec)   </td></tr>
<tr>
<td>29  </td><td>63  </td><td><img class="formulaInl" alt="$ 1.41802 \times 10^{-4} $" src="form_106.png"/>  </td><td>5.73   </td></tr>
<tr>
<td>84  </td><td>228  </td><td><img class="formulaInl" alt="$ 3.70896 \times 10^{-5} $" src="form_107.png"/>  </td><td>16.07   </td></tr>
<tr>
<td>250  </td><td>696  </td><td><img class="formulaInl" alt="$ 9.52325 \times 10^{-6} $" src="form_108.png"/>  </td><td>54.92   </td></tr>
<tr>
<td>2034  </td><td>5958  </td><td><img class="formulaInl" alt="$ 1.0478 \times 10^{-8} $" src="form_109.png"/>  </td><td>436.17   </td></tr>
<tr>
<td>4833  </td><td>14262  </td><td><img class="formulaInl" alt="$ 3.6392 \times 10^{-10} $" src="form_110.png"/>  </td><td>1749.63     </td></tr>
</table>
<br  />
 </center><p>Tables 1 and 2 show that the computational time for the <code>C1CurvedElement</code> is obviously very expensive compared to that of the <code>BellElement</code> when the same number of element is concerned. However, for the same number of elements, accuracies obtained from the curved elements are superior to those obtained from the straight elements.</p>
<p>Furthermore, if the same error is considered, say <img class="formulaInl" alt="$O(10^{-5})$" src="form_111.png"/>, it can be seen from Tables 1 and 2 that the number of the <code>BellElement</code> has to be 2034 to obtain such an accuracy. On the other hands, the number of the <code>C1CurvedElement</code> needed to obtain such accuracy is 84 which is a lot less. Also, the computational time to obtained the accuracy of order <img class="formulaInl" alt="$O(10^{-5})$" src="form_111.png"/> for the <code>BellElement</code> is 17.48 and for the <code>C1CurvedElement</code> is 16.07 which is smaller.</p>
<p>In order to compare the convergence rate between the <code>BellElement</code> and the <code>C1CurvedElement</code>, Fig. 1.5 illustrates the comparison between the <img class="formulaInl" alt="$L^2$" src="form_100.png"/>-norm error and the element size obtained from those elements. It can be seen that the <code>C1CurvedElement</code> converges faster and, also, gives smaller error than the <code>BellElement</code>.</p>
<p>When performing the log-plot between the <img class="formulaInl" alt="$L^2$" src="form_100.png"/>-norm error and the element size, Fig. 1.6 depicts that the convergence rate of the <code>C1CurvedElement</code> are greater than the <code>BellElement</code> as its slope is greater. The obtained rate of convergence for the <code>C1CurvedElement</code> and <code>the</code> BellElement is quintic and quadratic, respectively.</p>
<p>It is noteworthy that using the <code>BellElement</code> to solve the <img class="formulaInl" alt="$ C^1 $" src="form_0.png"/>-problem with a curved boundary domain decreases its rate of convergence from its potential when solving an exact representation domain (see <a href="../../../c1_element/bell_element/html/index.html">another tutorial</a>). This limitation of convergence rate in the <code>BellElement</code> is due to the representation of the curved boundaries with straight-edge elements.</p>
<div class="image">
<img src="Rate_of_convergence_compare.gif" alt=""/>
<div class="caption">
The comparison of the convergence rate between the Bell and the C1-curved triangular elements. </div></div>
 <div class="image">
<img src="Rate_of_convergence_compare_logplot.gif" alt=""/>
<div class="caption">
The comparison of the convergence rate between the Bell and the C1-curved triangular elements. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="impl"></a>
Implementation in oomph-lib</h1>
<p>In order to solve the Biharmonic equation with <code>oomph-lib</code>, the Global parameters and functions can be defined the same as in <a href="../../../c1_element/bell_element/html/index.html">another Biharmonic tutorial</a>. However, we use the <code>BiharmonicCurvedElement&lt;2,2&gt;</code> to solve the Biharmonic equation when the curvilinear boundary is concerned. This can be modified in the driver code.</p>
<p>In sequels, we will discuss only functions that defined differently from solving the Biharmonic equation with the <code>BellElement</code>.</p>
<hr  />
<h2><a class="anchor" id="problem"></a>
The problem class</h2>
<p>The problem class has five member functions, illustrated as follows:</p>
<ul>
<li>The problem constructor</li>
<li><code>action_before_newton_solve()</code> : Update the problem specifications before solve. Boundary conditions maybe set here.</li>
<li><code>action_after_newton_solve()</code> : Update the problem specifications after solve.</li>
<li><code>doc_solution()</code> : Pass the number of the case considered, so that output files can be distinguished.</li>
<li><code>nodal_permutation()</code> : Perform a nodal permutation in a curved element.</li>
</ul>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_problem_class============================================</span></div>
<div class="line"><span class="comment">/// 2D Biharmonic problem.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT, <span class="keywordtype">unsigned</span> DIM, <span class="keywordtype">unsigned</span> NNODE_1D&gt; </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classMyBiharmonicProblem.html">MyBiharmonicProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: Pass number of elements and pointer to source function</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classMyBiharmonicProblem.html#ab894abf54210a71c3b4e00e1b30e380e">MyBiharmonicProblem</a>(<span class="keyword">typename</span> MyBiharmonicEquations&lt;DIM,NNODE_1D&gt;::SourceFctPt source_fct_pt,</div>
<div class="line">                          <span class="keyword">typename</span> MyBiharmonicEquations&lt;DIM,NNODE_1D&gt;::ExactSolnPt exact_pt,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; node_file_name,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; element_file_name,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; poly_file_name);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Destructor (empty)</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classMyBiharmonicProblem.html#ad6d1bdce803ec5fd13bf6b0e3b1f3ca9">~MyBiharmonicProblem</a>()</div>
<div class="line">  {</div>
<div class="line">   <span class="keyword">delete</span> mesh_pt();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Update the problem specs before solve: (Re)set boundary conditions</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classMyBiharmonicProblem.html#ae9a9d6db2c84c3cc12138558b60d676d">actions_before_newton_solve</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs after solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classMyBiharmonicProblem.html#a0600c4a7dff6f362b6171c66e07b594c">actions_after_newton_solve</a>(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// \short Doc the solution, pass the number of the case considered,</span></div>
<div class="line"><span class="comment"> /// so that output files can be distinguished.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classMyBiharmonicProblem.html#aa1c9d6b8298b2b78f5df9343349ecd70">doc_solution</a>(DocInfo&amp; doc_info);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Perform a nodal permutation in curved elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classMyBiharmonicProblem.html#a40167119fb35b4926185b7adc23a6358">nodal_permutation</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to source function</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">typename</span> MyBiharmonicEquations&lt;DIM,NNODE_1D&gt;::SourceFctPt <a class="code" href="classMyBiharmonicProblem.html#a1ba6c64955d32e319db7a7de7807458a">Source_fct_pt</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the exact solution</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">typename</span> MyBiharmonicEquations&lt;DIM,NNODE_1D&gt;::ExactSolnPt <a class="code" href="classMyBiharmonicProblem.html#a9f681412ab2041bf3ddcd668ee816362">Exact_soln_pt</a>;</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// end of problem class</span></div>
</div><!-- fragment --><p>Only function <code>Problem::nodal_permutation()</code> is newly defined to associate with a curvilinear boundary. This function is employed to swap nodes so that they are correspond with the defined shape functions when using the <code>C1CurvedElement</code>.</p>
<hr  />
<h2><a class="anchor" id="permute"></a>
The nodal_permutation() function</h2>
<p>Regarding the mapping associated between the reference coordinates and the physical coordinates defined on the curved triangle, it can be seen that we defined the side <img class="formulaInl" alt="$ \hat{\bf{a}}_1\hat{\bf{a}}_2$" src="form_112.png"/> of the reference to associate with the curved boundary. Also, in the definition defined in (2), the vertex node <img class="formulaInl" alt="$ \bf{a}_1 $" src="form_113.png"/> was defined to be correspond with the position where <img class="formulaInl" alt="$ s $" src="form_92.png"/> is minimum on each arc of the curved boundary <img class="formulaInl" alt="$ \Gamma $" src="form_19.png"/> and the node <img class="formulaInl" alt="$ \bf{a}_2 $" src="form_114.png"/> was correspond with the position where the maximum <img class="formulaInl" alt="$ s $" src="form_92.png"/> is obtained. Furthermore, the node <img class="formulaInl" alt="$ \bf{a}_3 $" src="form_115.png"/> was defined to be the off-boundary node of a curved triangle.</p>
<p>However, a discretisation of the curvilinear domain by triangles can give a triangulation where the node ordering in a triangular element incompatible with the described definitions. As illustrated in the following figure, three cases of node ordering can happen.</p>
<div class="image">
<img src="node_ordering.gif" alt=""/>
<div class="caption">
The graphical description of node ordering. </div></div>
 <p>It can be seen from the definition in (2) and the figure that <img class="formulaInl" alt="$ F_{K}(\bf{\hat{a}}_{i}) = \bf{p}_{i}$" src="form_116.png"/> rather than <img class="formulaInl" alt="$ \bf{a}_i. $" src="form_117.png"/> Therefore, in order to derive our <img class="formulaInl" alt="$ C^1$" src="form_69.png"/>-curved triangular shape functions, a re-position of nodes has to be performed. The function <code>nodal_permutation(...)</code> will provide a nodal permutation where the nodal pointers will be swapped so that they are associated with the shape functions defined at that node. The nodal pointers will be permuted to correspond with the conditions required in (2).</p>
<p>Here are codes for a nodal permutation.</p>
 <div class="fragment"><div class="line"><span class="comment">//===start_of_nodal_permutation===========================================</span></div>
<div class="line"><span class="comment">/// \short Update the nodal permutation in curved elements: (Re)assign </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// coordinates so that the first and the second nodes are associated</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// with the lower and upper position on a boundary, respectively. </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// The third node is off-boundary node.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT, <span class="keywordtype">unsigned</span> DIM, <span class="keywordtype">unsigned</span> NNODE_1D&gt;</div>
<div class="line"> <span class="keywordtype">void</span> <a class="code" href="classMyBiharmonicProblem.html#a40167119fb35b4926185b7adc23a6358">MyBiharmonicProblem&lt;ELEMENT,DIM,NNODE_1D&gt;::nodal_permutation</a>()</div>
<div class="line">  {</div>
<div class="line">   DenseMatrix&lt;double&gt; position(3,2);</div>
<div class="line">   DenseMatrix&lt;double&gt; bd_position(20,2);</div>
<div class="line">   Vector&lt;double&gt; x(2);</div>
<div class="line">   <span class="keywordtype">unsigned</span> bd_element;</div>
<div class="line">  </div>
<div class="line">   <span class="comment">// Get number of elements in the mesh</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = mesh_pt()-&gt;nelement();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Start a classification of nodes</span></div>
<div class="line">   <span class="comment">// Loop over elements to get coordinates of nodes on a boundary</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_element;n++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Upcast from GeneralisedElement to the present element</span></div>
<div class="line">     ELEMENT *elem_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(n));</div>
<div class="line">     <span class="comment">// we need just three vertices</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> n_node = 3;</div>
<div class="line">   </div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> l=0;l&lt;n_node;l++)</div>
<div class="line">      {</div>
<div class="line">       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;DIM;j++)</div>
<div class="line">        {</div>
<div class="line">         position(l,j) = elem_pt-&gt;node_pt(l)-&gt;x(j);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    </div>
<div class="line">     <span class="keywordtype">int</span> count=0;</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// check whether this element is on boundary or not</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_node;i++)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">// check whether this node is on 1st boundary (curve boundary)</span></div>
<div class="line">       <span class="keywordtype">bool</span> bd_node1 = elem_pt-&gt;node_pt(i)-&gt;is_on_boundary(1);</div>
<div class="line">       <span class="keywordflow">if</span>(bd_node1==1)</div>
<div class="line">        {</div>
<div class="line">         count += 1;</div>
<div class="line">         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;DIM;j++)</div>
<div class="line">          {</div>
<div class="line">           bd_position(count-1,j) = elem_pt-&gt;node_pt(i)-&gt;x(j);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">       <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;DIM;j++)</div>
<div class="line">          {</div>
<div class="line">           x[j] = elem_pt-&gt;node_pt(i)-&gt;x(j);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">     </div>
<div class="line">     <span class="keywordflow">if</span>(count == 2) <span class="comment">// this case is a boundary element</span></div>
<div class="line">      {</div>
<div class="line">       bd_element = 1;</div>
<div class="line">      }          </div>
<div class="line">     <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">       bd_element = 0;           </div>
<div class="line">      } <span class="comment">// end_of_classification</span></div>
<div class="line">     <span class="comment"></span></div>
<div class="line"><span class="comment">     /// Permutation just for the curved elements</span></div>
<div class="line"><span class="comment"></span>     <span class="keywordflow">if</span>(bd_element==1)</div>
<div class="line">      {</div>
<div class="line">       <span class="keywordtype">unsigned</span> n_position_type = 6;</div>
<div class="line">       DenseMatrix&lt;double&gt; nodal_value(3,n_position_type,0.0);</div>
<div class="line">       <span class="keywordtype">double</span> angle_1 = atan(bd_position(0,1)/bd_position(0,0));</div>
<div class="line">       <span class="keywordtype">double</span> angle_2 = atan(bd_position(1,1)/bd_position(1,0));</div>
<div class="line">       </div>
<div class="line">       <span class="keywordflow">if</span>(angle_1 &gt; angle_2)</div>
<div class="line">        {</div>
<div class="line">         <span class="keywordflow">if</span>(position(2,0)==x[0] &amp;&amp; position(2,1)==x[1])                                  </div>
<div class="line">          {</div>
<div class="line">           Node* first_pt = elem_pt-&gt;node_pt(0);</div>
<div class="line">           elem_pt-&gt;node_pt(0) = elem_pt-&gt;node_pt(1);</div>
<div class="line">           elem_pt-&gt;node_pt(1) = first_pt;</div>
<div class="line">           </div>
<div class="line">           Node* second_pt = elem_pt-&gt;node_pt(3);</div>
<div class="line">           elem_pt-&gt;node_pt(3) = elem_pt-&gt;node_pt(4);</div>
<div class="line">           elem_pt-&gt;node_pt(5) = second_pt;                         </div>
<div class="line">          }</div>
<div class="line">         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(position(1,0)==bd_position(0,0) &amp;&amp; position(1,1)==bd_position(0,1))                                  </div>
<div class="line">          {</div>
<div class="line">           Node* first_pt = elem_pt-&gt;node_pt(2);</div>
<div class="line">           elem_pt-&gt;node_pt(0) = elem_pt-&gt;node_pt(2);</div>
<div class="line">           elem_pt-&gt;node_pt(2) = first_pt;</div>
<div class="line">           </div>
<div class="line">           Node* second_pt = elem_pt-&gt;node_pt(3);</div>
<div class="line">           elem_pt-&gt;node_pt(3) = elem_pt-&gt;node_pt(5);</div>
<div class="line">           elem_pt-&gt;node_pt(5) = second_pt;                         </div>
<div class="line">          }</div>
<div class="line">         <span class="keywordflow">else</span> </div>
<div class="line">          { </div>
<div class="line">           Node* first_pt = elem_pt-&gt;node_pt(0);</div>
<div class="line">           elem_pt-&gt;node_pt(0) = elem_pt-&gt;node_pt(2);</div>
<div class="line">           elem_pt-&gt;node_pt(2) = elem_pt-&gt;node_pt(1);</div>
<div class="line">           elem_pt-&gt;node_pt(1) = first_pt;</div>
<div class="line">           </div>
<div class="line">           Node* second_pt = elem_pt-&gt;node_pt(3);</div>
<div class="line">           elem_pt-&gt;node_pt(3) = elem_pt-&gt;node_pt(5);</div>
<div class="line">           elem_pt-&gt;node_pt(5) = elem_pt-&gt;node_pt(4);</div>
<div class="line">           elem_pt-&gt;node_pt(4) = second_pt;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(angle_1 &lt; angle_2)</div>
<div class="line">        {</div>
<div class="line">         <span class="keywordflow">if</span>(position(0,0)==bd_position(0,0) &amp;&amp; position(0,1)==bd_position(0,1))</div>
<div class="line">          {</div>
<div class="line">           <span class="keywordflow">if</span>(position(2,0)==bd_position(1,0) &amp;&amp; position(2,1)==bd_position(1,1))                                  </div>
<div class="line">            {</div>
<div class="line">             Node* first_pt = elem_pt-&gt;node_pt(1);</div>
<div class="line">             elem_pt-&gt;node_pt(1) = elem_pt-&gt;node_pt(2);</div>
<div class="line">             elem_pt-&gt;node_pt(2) = first_pt;</div>
<div class="line">             </div>
<div class="line">             Node* second_pt = elem_pt-&gt;node_pt(4);</div>
<div class="line">             elem_pt-&gt;node_pt(4) = elem_pt-&gt;node_pt(5);</div>
<div class="line">             elem_pt-&gt;node_pt(5) = second_pt;                         </div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">         <span class="keywordflow">else</span> </div>
<div class="line">          {</div>
<div class="line">           </div>
<div class="line">           Node* first_pt = elem_pt-&gt;node_pt(0);</div>
<div class="line">           elem_pt-&gt;node_pt(0) = elem_pt-&gt;node_pt(1);</div>
<div class="line">           elem_pt-&gt;node_pt(1) = elem_pt-&gt;node_pt(2);</div>
<div class="line">           elem_pt-&gt;node_pt(2) = first_pt;</div>
<div class="line">           </div>
<div class="line">           Node* second_pt = elem_pt-&gt;node_pt(3);</div>
<div class="line">           elem_pt-&gt;node_pt(3) = elem_pt-&gt;node_pt(4);</div>
<div class="line">           elem_pt-&gt;node_pt(4) = elem_pt-&gt;node_pt(5);</div>
<div class="line">           elem_pt-&gt;node_pt(5) = second_pt;</div>
<div class="line">          }   </div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }  <span class="comment">// end of permutation</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="constructor"></a>
The Problem constructor</h2>
<p>The problem constructor starts by overloading the function <code>Problem::mesh_pt()</code> and set to the specific mesh used in this problem. In this tutorial, we implement the problem with a 2D unstructured mesh which is externally created by <code>Triangle</code>. The generated output will be used to build the <code>oomph-lib</code> mesh. The reader may refer to <a href="../../../meshes/mesh_from_inline_triangle/html/index.html">another tutorial</a> to create an unstructured triangular mesh internally.</p>
 <div class="fragment"><div class="line"><span class="comment">//=====start_of_constructor===============================================</span></div>
<div class="line"><span class="comment">/// \short Constructor for 2D Biharmonic problem.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Discretise the 2D domain with n_element elements of type ELEMENT.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Specify function pointer to source function. </span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT, <span class="keywordtype">unsigned</span> DIM, <span class="keywordtype">unsigned</span> NNODE_1D&gt;</div>
<div class="line"><a class="code" href="classMyBiharmonicProblem.html#ab894abf54210a71c3b4e00e1b30e380e">MyBiharmonicProblem&lt;ELEMENT,DIM,NNODE_1D&gt;::MyBiharmonicProblem</a></div>
<div class="line">(<span class="keyword">typename</span> MyBiharmonicEquations&lt;DIM,NNODE_1D&gt;::SourceFctPt source_fct_pt,</div>
<div class="line"> <span class="keyword">typename</span> MyBiharmonicEquations&lt;DIM,NNODE_1D&gt;::ExactSolnPt exact_pt,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; node_file_name,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; element_file_name,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; poly_file_name) : </div>
<div class="line"> Source_fct_pt(source_fct_pt), Exact_soln_pt(exact_pt)</div>
<div class="line">{ </div>
<div class="line"> Problem::mesh_pt() = <span class="keyword">new</span> TriangleMesh&lt;ELEMENT&gt;(node_file_name,element_file_name,poly_file_name);</div>
</div><!-- fragment --><p>Next, the boundary conditions of the problem will be taken care. Since the Dirichlet boundary conditions are applied in this problem, we pin the nodal values and their first-order derivatives on all boundaries. In this study, we also set degrees of freedom associated with the second-order derivatives to be pinned in order to reduce the number of degrees of freedom in the problem.</p>
<p>Note that there are three boundaries on the quarter of the unit circular domain. The boundary identities are labelled anticlockwise where the first boundary is associated with the side <img class="formulaInl" alt="$ (x,y) = (0,y). $" src="form_118.png"/></p>
 <div class="fragment"><div class="line"> <span class="comment">// start_of_boundary_conditions</span></div>
<div class="line"> <span class="comment">// assign conditions at boundary 0</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> i=0;</div>
<div class="line"> <span class="keywordtype">unsigned</span>  n_node1 = mesh_pt()-&gt;nboundary_node(i);</div>
<div class="line"> cout  &lt;&lt; <span class="stringliteral">&quot;nnode on b0 = &quot;</span> &lt;&lt; n_node1 &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> n=0;n&lt;n_node1;n++)</div>
<div class="line">  {</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(0); </div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(1); </div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(2);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(3);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(4);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(5);</div>
<div class="line">  }</div>
<div class="line"> <span class="comment">// assign conditions at boundary 1</span></div>
<div class="line"> i=1;</div>
<div class="line"> n_node1 = mesh_pt()-&gt;nboundary_node(i);</div>
<div class="line"> cout  &lt;&lt; <span class="stringliteral">&quot;nnode on b1 = &quot;</span> &lt;&lt; n_node1 &lt;&lt; endl;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> n=0;n&lt;n_node1;n++)</div>
<div class="line">  {</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(0); </div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(1); </div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(2);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(3);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(4);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(5);</div>
<div class="line">  }</div>
<div class="line"> <span class="comment">// assign conditions at boundary 2</span></div>
<div class="line"> i=2;</div>
<div class="line"> n_node1 = mesh_pt()-&gt;nboundary_node(2);</div>
<div class="line"> cout  &lt;&lt; <span class="stringliteral">&quot;nnode on b2 = &quot;</span> &lt;&lt; n_node1 &lt;&lt; endl;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> n=0;n&lt;n_node1;n++)</div>
<div class="line">  {</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(0);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(1); </div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(2);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(3);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(4);</div>
<div class="line">   mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(5);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// end of boundary conditions</span></div>
</div><!-- fragment --><p>According to the <code>C1CurvedElement</code>, there are two different types of triangular elements which contain different numbers of nodes in an element. The straight-sided triangular elements constitute of three vertex nodes with out any interior node while the curved elements constitute of three vertices and three interior nodes. Since there are overall six nodes in <code>C1CurvedElement</code>, all three interior nodes have to be pinned when the straight-sided elements are concerned.</p>
 <div class="fragment"><div class="line">   <span class="comment">// pinned the unnecessary nodes in the straight-sided elements</span></div>
</div><!-- fragment --><p>We then loop over the elements and set the pointers to the physical parameters, the function pointer to the source function which is the function on the right-hand side of the Biharmonic equation, and the pointer to the exact solutions.</p>
 <div class="fragment"><div class="line"> <span class="comment">// Loop over elements and set pointers to Physical parameters</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_element;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to the present element</span></div>
<div class="line">   ELEMENT *elem_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(i));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set the source function pointer and all physical variables</span></div>
<div class="line">   elem_pt-&gt;source_fct_pt() = Source_fct_pt;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set the exact solution pointer</span></div>
<div class="line">   elem_pt-&gt;exact_pt() = Exact_soln_pt;</div>
<div class="line">  } <span class="comment">// end of pointers set up</span></div>
</div><!-- fragment --><p>Before we can implement a problem in a curved element, a nodal permutation is needed in order to satisfy (2). That is the coordinates of the first and the second nodes have to be associated with the lower and upper position on a boundary, respectively. Furthermore, the third node should be off-boundary.</p>
 <div class="fragment"><div class="line"> <span class="comment">/// Perform a nodal permutation in curved elements</span></div>
<div class="line"> <span class="keywordtype">void</span> nodal_permutation();</div>
</div><!-- fragment --><p>We finish the constructor by assigning the equation numbering scheme.  </p><div class="fragment"><div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> assign_eqn_numbers();</div>
<div class="line">} <span class="comment">// end of constructor</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/biharmonic/unstructured_2d_biharmonic/">demo_drivers/biharmonic/unstructured_2d_biharmonic/ </a> </center><br  />
</li>
<li>The driver code for the 2D Biharmonic problem with the <code>BellElement</code> is: <br  />
<br  />
<center> <a href="
../../../../
demo_drivers/biharmonic/unstructured_2d_biharmonic/unstructured_2d_biharmonic_bellelement.cc
">demo_drivers/biharmonic/unstructured_2d_biharmonic/unstructured_2d_biharmonic_bellelement.cc </a> </center></li>
<li>The driver code for the 2D Biharmonic problem with the <code>C1CurvedElement</code> is: <br  />
<br  />
<center> <a href="
../../../../
demo_drivers/biharmonic/unstructured_2d_biharmonic/unstructured_2d_biharmonic_curvedelement.cc
">demo_drivers/biharmonic/unstructured_2d_biharmonic/unstructured_2d_biharmonic_curvedelement.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="aclassMyBiharmonicProblem_html_ad6d1bdce803ec5fd13bf6b0e3b1f3ca9"><div class="ttname"><a href="classMyBiharmonicProblem.html#ad6d1bdce803ec5fd13bf6b0e3b1f3ca9">MyBiharmonicProblem::~MyBiharmonicProblem</a></div><div class="ttdeci">~MyBiharmonicProblem()</div><div class="ttdoc">Destructor (empty)</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01182">unstructured_2d_biharmonic_curvedelement.cc:1182</a></div></div>
<div class="ttc" id="aclassMyBiharmonicProblem_html"><div class="ttname"><a href="classMyBiharmonicProblem.html">MyBiharmonicProblem</a></div><div class="ttdoc">2D Biharmonic problem.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01170">unstructured_2d_biharmonic_curvedelement.cc:1170</a></div></div>
<div class="ttc" id="aclassMyBiharmonicProblem_html_aa1c9d6b8298b2b78f5df9343349ecd70"><div class="ttname"><a href="classMyBiharmonicProblem.html#aa1c9d6b8298b2b78f5df9343349ecd70">MyBiharmonicProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info)</div><div class="ttdoc">Doc the solution, pass the number of the case considered, so that output files can be distinguished.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01538">unstructured_2d_biharmonic_curvedelement.cc:1538</a></div></div>
<div class="ttc" id="aclassMyBiharmonicProblem_html_a0600c4a7dff6f362b6171c66e07b594c"><div class="ttname"><a href="classMyBiharmonicProblem.html#a0600c4a7dff6f362b6171c66e07b594c">MyBiharmonicProblem::actions_after_newton_solve</a></div><div class="ttdeci">void actions_after_newton_solve()</div><div class="ttdoc">Update the problem specs after solve (empty)</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01192">unstructured_2d_biharmonic_curvedelement.cc:1192</a></div></div>
<div class="ttc" id="aclassMyBiharmonicProblem_html_a9f681412ab2041bf3ddcd668ee816362"><div class="ttname"><a href="classMyBiharmonicProblem.html#a9f681412ab2041bf3ddcd668ee816362">MyBiharmonicProblem::Exact_soln_pt</a></div><div class="ttdeci">MyBiharmonicEquations&lt; DIM, NNODE_1D &gt;::ExactSolnPt Exact_soln_pt</div><div class="ttdoc">Pointer to the exact solution.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01207">unstructured_2d_biharmonic_curvedelement.cc:1207</a></div></div>
<div class="ttc" id="aclassMyBiharmonicProblem_html_ab894abf54210a71c3b4e00e1b30e380e"><div class="ttname"><a href="classMyBiharmonicProblem.html#ab894abf54210a71c3b4e00e1b30e380e">MyBiharmonicProblem::MyBiharmonicProblem</a></div><div class="ttdeci">MyBiharmonicProblem(typename MyBiharmonicEquations&lt; DIM, NNODE_1D &gt;::SourceFctPt source_fct_pt, typename MyBiharmonicEquations&lt; DIM, NNODE_1D &gt;::ExactSolnPt exact_pt, const string &amp;node_file_name, const string &amp;element_file_name, const string &amp;poly_file_name)</div><div class="ttdoc">Constructor: Pass number of elements and pointer to source function.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01222">unstructured_2d_biharmonic_curvedelement.cc:1222</a></div></div>
<div class="ttc" id="aclassMyBiharmonicProblem_html_a1ba6c64955d32e319db7a7de7807458a"><div class="ttname"><a href="classMyBiharmonicProblem.html#a1ba6c64955d32e319db7a7de7807458a">MyBiharmonicProblem::Source_fct_pt</a></div><div class="ttdeci">MyBiharmonicEquations&lt; DIM, NNODE_1D &gt;::SourceFctPt Source_fct_pt</div><div class="ttdoc">Pointer to source function.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01204">unstructured_2d_biharmonic_curvedelement.cc:1204</a></div></div>
<div class="ttc" id="aclassMyBiharmonicProblem_html_ae9a9d6db2c84c3cc12138558b60d676d"><div class="ttname"><a href="classMyBiharmonicProblem.html#ae9a9d6db2c84c3cc12138558b60d676d">MyBiharmonicProblem::actions_before_newton_solve</a></div><div class="ttdeci">void actions_before_newton_solve()</div><div class="ttdoc">Update the problem specs before solve: (Re)set boundary conditions.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01498">unstructured_2d_biharmonic_curvedelement.cc:1498</a></div></div>
<div class="ttc" id="aclassMyBiharmonicProblem_html_a40167119fb35b4926185b7adc23a6358"><div class="ttname"><a href="classMyBiharmonicProblem.html#a40167119fb35b4926185b7adc23a6358">MyBiharmonicProblem::nodal_permutation</a></div><div class="ttdeci">void nodal_permutation()</div><div class="ttdoc">Perform a nodal permutation in curved elements.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__2d__biharmonic__curvedelement_8cc_source.html#l01355">unstructured_2d_biharmonic_curvedelement.cc:1355</a></div></div>

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Fri Jul 9 2021 21:23:38
        </div>
      </div>
    </footer>
</body>
</html>
