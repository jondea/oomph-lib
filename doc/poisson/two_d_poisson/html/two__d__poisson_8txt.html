<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: two_d_poisson.txt File Reference</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Get it <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/subversion/html/index.html">Get code from subversion repository</a></li>
            <li><a href="../../../../doc/download/html/index.html">Get code as tar file</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">two_d_poisson.txt File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa166dca8d99a7a36f016ae036351695c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="two__d__poisson_8txt.html#aa166dca8d99a7a36f016ae036351695c">i</a> = 1}^2 \frac{\partial^2u}{\partial x_i^2}=f(x_1, x_2), \ \ \ \ \ \ \ \ \ \ @E[2DPoisson]@ \f] in the rectangular domain \f $D=\left\{(x_1, x_2) \in[0, 1] \times[0, 2]\right\}\f$, with Dirichlet boundary conditions \f[\left. u\right|_{\partial D}=u_0 \ \ \ \ \ \ \ \ \ \ @E[2DPoisson_BC]@ \f] where the function \f$ u_0 \f$ is given.&lt;/TD &gt;&lt;/TR &gt;&lt;/TABLE &gt;&lt;/CENTER &gt; We provide a detailed discussion of the driver code&lt; A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson.cc&quot;&gt; two_d_poisson.cc&lt;/A &gt; which solves the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> for \f[u_0(x_1, x_2)=\tanh(1-\alpha(x_1 \tan\Phi - x_2)), \ \ \ \ \ \ \ \ \ @E[ExactSoln]@ \f] and \f[f(x_1, x_2)=\sum_{<a class="el" href="two__d__poisson_8txt.html#aa166dca8d99a7a36f016ae036351695c">i</a>=1}^2 \frac{\partial^2 u_0}{\partial x_i^2}, \ \ \ \ \ \ \ \ \ @E[SourceFct]@ \f] so that \f $u_0(x_1, x_2) \f$ represents the exact solution of the problem. For large values of \f$ \alpha \f$ the solution approaches a step function \f[u_{step}(x_1, x_2)=\left\{ \begin{array}{rl} -1 &amp;\mbox {for $x_2&lt; x_1 \ \tan\Phi$} \\ 1 &amp;\mbox {for $x_2 &gt; x_1 \ \tan\Phi$} \end{array} \right. \f] which presents a serious challenge for any numerical method. The figure below compares the numerical and exact solutions for \f$ \alpha=1 \f$ and \f$\Phi=45^o\f$. @I w 0.75\textwidth two_d_poisson_soln &quot;Plot of the solution &quot;&lt; HR &gt;&lt; HR &gt; \section global Global parameters and functions Following our usual practice, we use a namespace, \c TanhSolnForPoisson, to define the source function( @R[SourceFct]@) and the exact solution( @R[ExactSoln]@). Both functions permit arbitrary values of the tangent \f$ \tan \Phi \f$ and the steepness parameter \f$ \alpha \f$, which are stored in <a class="el" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanhSolnForPoisson::TanPhi</a> and <a class="el" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">TanhSolnForPoisson::Alpha</a>, respectively, so that the &quot;user&quot; can set their values from the driver code. \dontinclude two_d_poisson.cc \skipline start_of_namespace \until end of namespace&lt; HR &gt;&lt; HR &gt; \section <a class="el" href="two__d__poisson__compare__solvers_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> The driver code In order to solve the 2D Poisson <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> using \c oomph-lib, we represent the mathematical <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> defined by equations( @R[2DPoisson]@) and( @R[2DPoisson_BC]@) in a specific \c Problem object, \c PoissonProblem. \c oomph-lib provides a variety of 2D Poisson elements(e.g. 2D quadrilateral elements with bi-linear, bi-quadratic and bi-cubic representations for the unknown function) and we pass the specific element type as a template parameter to the \c Problem. In the driver code, listed below, we use the \c QPoissonElement&lt; 2, 3 &gt;, a nine-node(bi-quadratic) 2D Poisson element. The next few lines of the \c <a class="el" href="two__d__poisson__compare__solvers_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() function create a \c DocInfo object -- an \c oomph-lib object that collates various items of data that can be used to label output files:Here we specify that the output files are to be written to the directory &quot;RESLT&quot;, and that the first batch of output files should be labelled with the identifier &quot;0&quot;. See the discussion of the postprocessing routine \c doc_solution(...) for details.[\b Note:While the ability to specify an output directory from the driver code is useful, it does rely on the &quot;user&quot; having created the directory before the code is executed. We could use the C++\c system(...) function to issue a system command which creates the directory if it does not exist. Since this would make the code non-portable, we only issue a warning suggesting the likely cause of the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> if the output file cannot be opened. If you want to make absolutely sure that the output directory does exist and can be written to, you can change this forgiving behaviour with the function \c DocInfo::directory_must_exist(). This function provides access to a boolean flag which is set to \c false by default. If set to \c true, the code execution terminates with \c assert(false) if the directory specified with \c DocInfo::set_directory(...) cannot be written to.] Next we execute the \c Problem::self_test() function to check whether the \c Problem has been correctly initialised. If this test is passed, we proceed to the solution. We choose the angle of the &quot;step&quot; as 45 degrees(corresponding to \f$ \tan \Phi=1 \f$) and then solve the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> for a number of values of the steepness parameter \f$ \alpha. \f$ We document each solution with the post-processing routine \c doc_solution(...) which accesses the step number and the output directory via the \c DocInfo object. \dontinclude two_d_poisson.cc \skipline start_of_main \until end of <a class="el" href="two__d__poisson__compare__solvers_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>&lt; HR &gt;&lt; HR &gt; \section <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> The <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> class The \c <a class="el" href="classPoissonProblem.html">PoissonProblem</a> is derived from \c oomph-lib 's generic \c Problem class and the specific element type is specified as a template parameter to make it easy for the &quot;user&quot; to change the element type from the driver code. \dontinclude two_d_poisson.cc \skipline start_of_problem_class \until public Problem The <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> class has five member functions, only three of which are non-trivial:- the constructor \c <a class="el" href="classPoissonProblem.html">PoissonProblem</a>(...) - the function \c actions_before_newton_solve() - the function \c doc_solution(...) . The function \c Problem::actions_after_newton_solve() is a pure virtual member function of the \c Problem base class and must be provided. However, it is not required in the present <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> and we leave it empty. Similarly, the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> destructor can remain empty as all memory de-allocation is handled in the destructor of the \c Problem base class. The Problem only stores one private data member, the pointer to the source function. \skipline public:\until end of <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> class[See the discussion of the&lt; A HREF=&quot;../../../poisson/one_d_poisson/html/index.html&quot;&gt; 1D Poisson <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a>&lt;/A &gt; for a more detailed discussion of the function type PoissonEquations&lt; 2 &gt;::PoissonSourceFctPt.]&lt; HR &gt;&lt; HR &gt; \section constructor The Problem constructor In the \c Problem constructor, we start by discretising the rectangular domain, using \c oomph-lib 's \c SimpleRectangularQuadMesh object. The arguments of this object 's constructor are the number of elements(whose type is specified by the template parameter), and the domain lengths in the \f $x_1 \f$ and \f $x_2 \f$ directions, respectively. The subsequent lines of code pin the nodal values along the entire domain boundary. In the&lt; A HREF=&quot;../../../poisson/one_d_poisson/html/index.html&quot;&gt; 1D example&lt;/A &gt; considered earlier, the identification of the nodes on the domain boundaries was trivial. In higher-dimensional problems, this task can become rather involved. \c oomph-lib 's \c Mesh base class provides the helper function \c Mesh::boundary_node_pt(...) giving(pointer-based) access to nodes on specified mesh boundaries.[The total number of boundaries can be obtained from \c Mesh::nboundary(), while the number of nodes on a specific boundary is available from \c Mesh::nboundary_node(...).] The nested loops over the mesh boundaries and the nodes on these boundaries therefore provide a convenient and completely generic method of accessing all boundary nodes. Finally we loop over all elements to assign the source function pointer, and then call the generic \c Problem::assign_eqn_numbers() routine to set up the equation numbers. \skipline start_of_constructor \until end of constructor&lt; HR &gt;&lt; HR &gt; \section actions_before &quot;Actions before solve&quot; We use \c Problem::actions_before_newton_solve() to update the boundary conditions in response to possible changes in the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> parameters. We use the exact solution, specified in \c <a class="el" href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">TanhSolnForPoisson::get_exact_u</a>(...), to determine the boundary values that are appropriate for the current values of \f$ \alpha \f$ and \f$ \tan \Phi \f$. \skipline start_of_actions_before_newton_solve \until end of actions before solve[See the discussion of the&lt; A HREF=&quot;../../../poisson 1D Poisson <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a>&lt;/A&gt; for a more detailed discussion of the pure virtual functions \c Problem::actions_before_newton_solve() and \c Problem::actions_after_newton_solve().] &lt;HR&gt; &lt;HR&gt; \section doc Post-processing The function \c doc_solution(...) writes the FE solution and the corresponding exact solution, defined in \c <a class="el" href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">TanhSolnForPoisson::get_exact_u</a>(...) to disk. The \c DocInfo object specifies the output directory and the label for the file names. [See the discussion of the &lt;A HREF=&quot;../../../poisson/one_d_poisson/html/index.html&quot;&gt; 1D Poisson <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a>&lt;/A&gt; for a more detailed discussion of the generic \c Mesh member functions \c Mesh::output(...), \c Mesh::output_fct(...) and \c Mesh::compute_error(...)]. \skipline start_of_doc \until end of doc &lt;HR&gt; &lt;HR&gt; \section exercises Comments and exercises -# In its current form, the number of elements and the dimensions of the domain are hard-coded in the \c Problem constructor. Change the \c Problem constructor so that these quantities become input parameters that can be set from the \c <a class="el" href="two__d__poisson__compare__solvers_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() function. -# Note how the accuracy of the FE solution decreases as the steepness of the &quot;step&quot; is increased: @I w 0.75\textwidth alpha &quot;Plot of the solution for different values of the steepness parameter &quot; How many elements are required to resolve the solution with \f$ \alpha = 10 \f$ as accurately as in the case of \f$ \alpha = 1\f$? [\b Note: Since the solution has steep gradients only in a very narrow region, uniform mesh refinement is an extremely wasteful method of improving the accuracy of the computed solution. \c oomph-lib provides powerful mesh adaptation routines which perform fully-automatic mesh refinement and unrefinement, based on a posteriori error estimates of the solution. We will demonstrate these in &lt;A HREF=&quot;../../../poisson/fish_poisson/html/index.html&quot;&gt; another example.&lt;/A&gt;] -# Repeat the numerical experiments with different element types. Replace the nine-node Poisson element, \c QPoissonElement&lt;2,3&gt;, by its lower- and higher-order counterparts \c QPoissonElement&lt;2,2&gt; and \c QPoissonElement&lt;2,4&gt;, respectively. Compare the total number of degrees of freedom, the errors, and the <a class="el" href="two__d__poisson__compare__solvers_8cc.html#a23bdfecb707db57cd809897a41b71297">run</a>-times for the different discretisations. \subsection precompile_mesh Header files and precompiled meshes We have repeatedly stressed that \c oomph-lib \c Mesh objects are (and any user-written ones should be) templated by the element type, so that meshes can be used with all finite elements that are derived from the same geometric element (2D quad elements from the \c QElement family, say). Typically, the element type is specified in the driver code. Consequently, the compiler must instantiate the \c Mesh object for a particular element type when the driver code is compiled -- there is no point in trying to &quot;pre-compile&quot; a \c Mesh object for &quot;all possible element types&quot;. The source code for \c Mesh objects is therefore usually contained in a single (header) file which must be included in the driver code. The first few lines of the driver code &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson.cc&quot;&gt; two_d_poisson.cc&lt;/A&gt; illustrate the technique: \dontinclude two_d_poisson.cc \skipline Driver for \until meshes/simple The code uses objects from the \c generic and \c poisson libraries whose function prototypes are contained in the header files \c generic.h and \c poisson.h, located in the \c oomph-lib \c include directory. All objects in these libraries are fully instantiated and no re-compilation is required -- we simply link against the libraries which are located in \c oomph-lib's \c lib directory. The mesh header files (which include the entire source code for each mesh) are located in the include (sub-)directory \c include/meshes, and are included into the driver code with a C++ include directive While this strategy greatly facilitates code reuse, it can incur significant compile-time overheads as the (possibly very lengthy) mesh sources must be recompiled whenever the driver code is changed. During code development, this overhead can become unacceptable. To avoid the constant re-compilation of the mesh sources, all \c oomph-lib mesh objects are contained in two separate source files. In the case of the \c SimpleRectangularMesh, the class definition and function prototypes are contained in the small auxiliary header file \c simple_rectangular_quadmesh.template.h, while the actual function definitions are contained in \c simple_rectangular_quadmesh.template.cc. These are the only sources that the mesh-writer has to provide. The header file \c simple_rectangular_quadmesh.h is generated (automatically) by concatenating the two *.template.* files and all three files are contained in the mesh include directory. This allows the &quot;user&quot; to pre-compile the mesh for a specific element type (or for a range of specific elements) to produce a separate object file that can be linked against when the driver code is built. The procedure is illustrated in the alternative source code &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson2.cc&quot;&gt; two_d_poisson2.cc&lt;/A&gt; and the associated mesh file, &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson2_mesh.cc&quot;&gt; two_d_poisson2_mesh.cc&lt;/A&gt;. In the original version of the code, &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson.cc&quot;&gt; two_d_poisson.cc&lt;/A&gt;, the mesh was instantiated with the element type \c QPoissonElement&lt;2,3&gt; and we will assume that this is the only element type required in the driver code. We force the instantiation of the \c SimpleRectangularQuadMesh for this element type by employing the C++ &quot;template&quot; statement in the mesh file, &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson2_mesh.cc&quot;&gt; two_d_poisson2_mesh.cc&lt;/A&gt;, which is listed in its entirety here: \include two_d_poisson2_mesh.cc This source file can be pre-compiled into an object file, \c two_d_poisson2_mesh.o, say. The driver code only needs to include the templated header file (which contains the class definition and the function prototypes) so that the first few lines of the modified driver code look like this: \dontinclude two_d_poisson2.cc \skipline Driver for \until meshes/simple The driver code can now be compiled separately (without having to recompile the mesh sources every time) and the correctly instantiated version of the \c SimpleRectangularQuadMesh can be made available by including \c two_d_poisson2_mesh.o during the linking phase. \subsection different_solvers How to choose the linear solver for the Newton method \c oomph-lib treats all problems as nonlinear problems and provides steady (and unsteady) Newton solvers to solve the system of nonlinear algebraic equations that arise from the spatial (and temporal) discretisation of the governing equations. Typically, the repeated assembly of the Jacobian matrix and the solution of the linear systems during the Newton iteration provides the major part of the computational work. Within this framework linear problems are simply special cases of nonlinear problems for which the Newton method converges in one iteration. The assembly of the Jacobian matrix and the solution of the linear system is performed by \c oomph-lib's \c LinearSolver objects. These typically provide interfaces to general purpose linear solvers such as \c SuperLUSolver (our default solver). The list of solvers includes: - \c SuperLUSolver: An interface to Demmel, Eistenstat, Gilbert, Li &amp; Liu's serial SuperLU solver. See &lt;A HREF=&quot;http:http:- \c HSL_MA42:An interface to the MA42 frontal solver from the HSL library. See&lt; A HREF=&quot;http: http: for details. - \c FD_LU: An extremely inefficient solver which computes the Jacobian matrix by finite differencing and stores it in a dense matrix. This solver is mainly provided to facilitate sanity checks during code development. (The residuals are easier to compute than the the Jacobian matrix!) - ...and many others. See the &lt;a href=&quot;../../../linear_solvers/html/index.html&quot;&gt;Linear Solvers Tutorial&lt;/a&gt; for a more detailed discussion of \c oomph-lib's various direct and iterative solvers. . By default the \c oomph-lib Newton solvers use \c SuperLU with compressed row storage for the Jacobian matrix as the linear solver. To change the linear solver to another type you can over-write the \c Problem's pointer to its linear solver. For instance, to change the linear solver to \c HSL_MA42, add the following lines to the \c Problem constructor: \code Problem::linear_solver_pt() = new HSL_MA42</td></tr>
<tr class="separator:aa166dca8d99a7a36f016ae036351695c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adff9ced81c6476b852d5feaad9392c1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="two__d__poisson_8txt.html#adff9ced81c6476b852d5feaad9392c1b">static_cast&lt; HSL_MA42 * &gt;</a> (Problem::linear_solver_pt()) -&gt; doc_stats()=true</td></tr>
<tr class="memdesc:adff9ced81c6476b852d5feaad9392c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch on full doc for frontal solver.  <a href="two__d__poisson_8txt.html#adff9ced81c6476b852d5feaad9392c1b">More...</a><br /></td></tr>
<tr class="separator:adff9ced81c6476b852d5feaad9392c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4074baada03976c061d5672f4237cca5"><td class="memItemLeft" align="right" valign="top">mainpage Demo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a></td></tr>
<tr class="separator:a4074baada03976c061d5672f4237cca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa166dca8d99a7a36f016ae036351695c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa166dca8d99a7a36f016ae036351695c">&#9670;&nbsp;</a></span>i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="two__d__poisson_8txt.html#aa166dca8d99a7a36f016ae036351695c">i</a> =  1}^2 \frac{\partial^2u}{\partial x_i^2} = f(x_1,x_2), \ \ \ \ \ \ \ \ \ \ @E[2DPoisson]@ \f] in the rectangular domain \f$D =\left\{ (x_1,x_2) \in [0,1] \times [0,2]\right\}\f$, with Dirichlet boundary conditions \f[ \left. u\right|_{\partial D}=u_0 \ \ \ \ \ \ \ \ \ \ @E[2DPoisson_BC]@ \f] where the function \f$ u_0 \f$ is given. &lt;/TD&gt; &lt;/TR&gt; &lt;/TABLE&gt; &lt;/CENTER&gt; We provide a detailed discussion of the driver code &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson.cc&quot;&gt; two_d_poisson.cc&lt;/A&gt; which solves the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> for \f[ u_0(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)), \ \ \ \ \ \ \ \ \ @E[ExactSoln]@ \f] and \f[ f(x_1,x_2) = \sum_{<a class="el" href="two__d__poisson_8txt.html#aa166dca8d99a7a36f016ae036351695c">i</a>=1}^2 \frac{\partial^2 u_0}{\partial x_i^2}, \ \ \ \ \ \ \ \ \ @E[SourceFct]@ \f] so that \f$u_0(x_1,x_2) \f$ represents the exact solution of the problem. For large values of \f$ \alpha \f$ the solution approaches a step function \f[ u_{step}(x_1,x_2) = \left\{ \begin{array}{rl} -1 &amp; \mbox {for $x_2 &lt; x_1 \ \tan\Phi$} \\ 1 &amp; \mbox {for $x_2 &gt; x_1 \ \tan\Phi$} \end{array} \right. \f] which presents a serious challenge for any numerical method. The figure below compares the numerical and exact solutions for \f$ \alpha = 1 \f$ and \f$\Phi = 45^o\f$. @I w 0.75\textwidth two_d_poisson_soln &quot;Plot of the solution &quot; &lt;HR&gt; &lt;HR&gt; \section global Global parameters and functions Following our usual practice, we use a namespace, \c TanhSolnForPoisson, to define the source function (@R[SourceFct]@) and the exact solution (@R[ExactSoln]@). Both functions permit arbitrary values of the tangent \f$ \tan \Phi \f$ and the steepness parameter \f$ \alpha \f$, which are stored in <a class="el" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanhSolnForPoisson::TanPhi</a> and <a class="el" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">TanhSolnForPoisson::Alpha</a>, respectively, so that the &quot;user&quot; can set their values from the driver code. \dontinclude two_d_poisson.cc \skipline start_of_namespace \until end of namespace &lt;HR&gt; &lt;HR&gt; \section <a class="el" href="two__d__poisson__compare__solvers_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> The driver code In order to solve the 2D Poisson <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> using \c oomph-lib, we represent the mathematical <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> defined by equations (@R[2DPoisson]@) and (@R[2DPoisson_BC]@) in a specific \c Problem object, \c PoissonProblem. \c oomph-lib provides a variety of 2D Poisson elements (e.g. 2D quadrilateral elements with bi-linear, bi-quadratic and bi-cubic representations for the unknown function) and we pass the specific element type as a template parameter to the \c Problem. In the driver code, listed below, we use the \c QPoissonElement&lt;2,3&gt;, a nine-node (bi-quadratic) 2D Poisson element. The next few lines of the \c <a class="el" href="two__d__poisson__compare__solvers_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() function create a \c DocInfo object -- an \c oomph-lib object that collates various items of data that can be used to label output files: Here we specify that the output files are to be written to the directory &quot;RESLT&quot;, and that the first batch of output files should be labelled with the identifier &quot;0&quot;. See the discussion of the postprocessing routine \c doc_solution(...) for details. [\b Note: While the ability to specify an output directory from the driver code is useful, it does rely on the &quot;user&quot; having created the directory before the code is executed. We could use the C++ \c system(...) function to issue a system command which creates the directory if it does not exist. Since this would make the code non-portable, we only issue a warning suggesting the likely cause of the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> if the output file cannot be opened. If you want to make absolutely sure that the output directory does exist and can be written to, you can change this forgiving behaviour with the function \c DocInfo::directory_must_exist(). This function provides access to a boolean flag which is set to \c false by default. If set to \c true, the code execution terminates with \c assert(false) if the directory specified with \c DocInfo::set_directory(...) cannot be written to.] Next we execute the \c Problem::self_test() function to check whether the \c Problem has been correctly initialised. If this test is passed, we proceed to the solution. We choose the angle of the &quot;step&quot; as 45 degrees (corresponding to \f$ \tan \Phi = 1 \f$) and then solve the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> for a number of values of the steepness parameter \f$ \alpha. \f$ We document each solution with the post-processing routine \c doc_solution(...) which accesses the step number and the output directory via the \c DocInfo object. \dontinclude two_d_poisson.cc \skipline start_of_main \until end of <a class="el" href="two__d__poisson__compare__solvers_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> &lt;HR&gt; &lt;HR&gt; \section <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> The <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> class The \c <a class="el" href="classPoissonProblem.html">PoissonProblem</a> is derived from \c oomph-lib's generic \c Problem class and the specific element type is specified as a template parameter to make it easy for the &quot;user&quot; to change the element type from the driver code. \dontinclude two_d_poisson.cc \skipline start_of_problem_class \until public Problem The <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> class has five member functions, only three of which are non-trivial: - the constructor \c <a class="el" href="classPoissonProblem.html">PoissonProblem</a>(...) - the function \c actions_before_newton_solve() - the function \c doc_solution(...) . The function \c Problem::actions_after_newton_solve() is a pure virtual member function of the \c Problem base class and must be provided. However, it is not required in the present <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> and we leave it empty. Similarly, the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> destructor can remain empty as all memory de-allocation is handled in the destructor of the \c Problem base class. The Problem only stores one private data member, the pointer to the source function. \skipline public: \until end of <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> class [See the discussion of the &lt;A HREF=&quot;../../../poisson/one_d_poisson/html/index.html&quot;&gt; 1D Poisson <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a>&lt;/A&gt; for a more detailed discussion of the function type PoissonEquations&lt;2&gt;::PoissonSourceFctPt.] &lt;HR&gt; &lt;HR&gt; \section constructor The Problem constructor In the \c Problem constructor, we start by discretising the rectangular domain, using \c oomph-lib's \c SimpleRectangularQuadMesh object. The arguments of this object's constructor are the number of elements (whose type is specified by the template parameter), and the domain lengths in the \f$x_1 \f$ and \f$x_2 \f$ directions, respectively. The subsequent lines of code pin the nodal values along the entire domain boundary. In the &lt;A HREF=&quot;../../../poisson/one_d_poisson/html/index.html&quot;&gt; 1D example&lt;/A&gt; considered earlier, the identification of the nodes on the domain boundaries was trivial. In higher-dimensional problems, this task can become rather involved. \c oomph-lib's \c Mesh base class provides the helper function \c Mesh::boundary_node_pt(...) giving (pointer-based) access to nodes on specified mesh boundaries. [The total number of boundaries can be obtained from \c Mesh::nboundary(), while the number of nodes on a specific boundary is available from \c Mesh::nboundary_node(...).] The nested loops over the mesh boundaries and the nodes on these boundaries therefore provide a convenient and completely generic method of accessing all boundary nodes. Finally we loop over all elements to assign the source function pointer, and then call the generic \c Problem::assign_eqn_numbers() routine to set up the equation numbers. \skipline start_of_constructor \until end of constructor &lt;HR&gt; &lt;HR&gt; \section actions_before &quot;Actions before solve&quot; We use \c Problem::actions_before_newton_solve() to update the boundary conditions in response to possible changes in the <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a> parameters. We use the exact solution, specified in \c <a class="el" href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">TanhSolnForPoisson::get_exact_u</a>(...), to determine the boundary values that are appropriate for the current values of \f$ \alpha \f$ and \f$ \tan \Phi \f$. \skipline start_of_actions_before_newton_solve \until end of actions before solve [See the discussion of the &lt;A HREF=&quot;../../../poisson 1D Poisson <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a>&lt;/A&gt; for a more detailed discussion of the pure virtual functions \c Problem::actions_before_newton_solve() and \c Problem::actions_after_newton_solve().] &lt;HR&gt; &lt;HR&gt; \section doc Post-processing The function \c doc_solution(...) writes the FE solution and the corresponding exact solution, defined in \c <a class="el" href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">TanhSolnForPoisson::get_exact_u</a>(...) to disk. The \c DocInfo object specifies the output directory and the label for the file names. [See the discussion of the &lt;A HREF=&quot;../../../poisson/one_d_poisson/html/index.html&quot;&gt; 1D Poisson <a class="el" href="two__d__poisson_8txt.html#a4074baada03976c061d5672f4237cca5">problem</a>&lt;/A&gt; for a more detailed discussion of the generic \c Mesh member functions \c Mesh::output(...), \c Mesh::output_fct(...) and \c Mesh::compute_error(...)]. \skipline start_of_doc \until end of doc &lt;HR&gt; &lt;HR&gt; \section exercises Comments and exercises -# In its current form, the number of elements and the dimensions of the domain are hard-coded in the \c Problem constructor. Change the \c Problem constructor so that these quantities become input parameters that can be set from the \c <a class="el" href="two__d__poisson__compare__solvers_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() function. -# Note how the accuracy of the FE solution decreases as the steepness of the &quot;step&quot; is increased: @I w 0.75\textwidth alpha &quot;Plot of the solution for different values of the steepness parameter &quot; How many elements are required to resolve the solution with \f$ \alpha = 10 \f$ as accurately as in the case of \f$ \alpha = 1\f$? [\b Note: Since the solution has steep gradients only in a very narrow region, uniform mesh refinement is an extremely wasteful method of improving the accuracy of the computed solution. \c oomph-lib provides powerful mesh adaptation routines which perform fully-automatic mesh refinement and unrefinement, based on a posteriori error estimates of the solution. We will demonstrate these in &lt;A HREF=&quot;../../../poisson/fish_poisson/html/index.html&quot;&gt; another example.&lt;/A&gt;] -# Repeat the numerical experiments with different element types. Replace the nine-node Poisson element, \c QPoissonElement&lt;2,3&gt;, by its lower- and higher-order counterparts \c QPoissonElement&lt;2,2&gt; and \c QPoissonElement&lt;2,4&gt;, respectively. Compare the total number of degrees of freedom, the errors, and the <a class="el" href="two__d__poisson__compare__solvers_8cc.html#a23bdfecb707db57cd809897a41b71297">run</a>-times for the different discretisations. \subsection precompile_mesh Header files and precompiled meshes We have repeatedly stressed that \c oomph-lib \c Mesh objects are (and any user-written ones should be) templated by the element type, so that meshes can be used with all finite elements that are derived from the same geometric element (2D quad elements from the \c QElement family, say). Typically, the element type is specified in the driver code. Consequently, the compiler must instantiate the \c Mesh object for a particular element type when the driver code is compiled -- there is no point in trying to &quot;pre-compile&quot; a \c Mesh object for &quot;all possible element types&quot;. The source code for \c Mesh objects is therefore usually contained in a single (header) file which must be included in the driver code. The first few lines of the driver code &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson.cc&quot;&gt; two_d_poisson.cc&lt;/A&gt; illustrate the technique: \dontinclude two_d_poisson.cc \skipline Driver for \until meshes/simple The code uses objects from the \c generic and \c poisson libraries whose function prototypes are contained in the header files \c generic.h and \c poisson.h, located in the \c oomph-lib \c include directory. All objects in these libraries are fully instantiated and no re-compilation is required -- we simply link against the libraries which are located in \c oomph-lib's \c lib directory. The mesh header files (which include the entire source code for each mesh) are located in the include (sub-)directory \c include/meshes, and are included into the driver code with a C++ include directive While this strategy greatly facilitates code reuse, it can incur significant compile-time overheads as the (possibly very lengthy) mesh sources must be recompiled whenever the driver code is changed. During code development, this overhead can become unacceptable. To avoid the constant re-compilation of the mesh sources, all \c oomph-lib mesh objects are contained in two separate source files. In the case of the \c SimpleRectangularMesh, the class definition and function prototypes are contained in the small auxiliary header file \c simple_rectangular_quadmesh.template.h, while the actual function definitions are contained in \c simple_rectangular_quadmesh.template.cc. These are the only sources that the mesh-writer has to provide. The header file \c simple_rectangular_quadmesh.h is generated (automatically) by concatenating the two *.template.* files and all three files are contained in the mesh include directory. This allows the &quot;user&quot; to pre-compile the mesh for a specific element type (or for a range of specific elements) to produce a separate object file that can be linked against when the driver code is built. The procedure is illustrated in the alternative source code &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson2.cc&quot;&gt; two_d_poisson2.cc&lt;/A&gt; and the associated mesh file, &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson2_mesh.cc&quot;&gt; two_d_poisson2_mesh.cc&lt;/A&gt;. In the original version of the code, &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson.cc&quot;&gt; two_d_poisson.cc&lt;/A&gt;, the mesh was instantiated with the element type \c QPoissonElement&lt;2,3&gt; and we will assume that this is the only element type required in the driver code. We force the instantiation of the \c SimpleRectangularQuadMesh for this element type by employing the C++ &quot;template&quot; statement in the mesh file, &lt;A HREF=&quot;../../../../demo_drivers/poisson/two_d_poisson/two_d_poisson2_mesh.cc&quot;&gt; two_d_poisson2_mesh.cc&lt;/A&gt;, which is listed in its entirety here: \include two_d_poisson2_mesh.cc This source file can be pre-compiled into an object file, \c two_d_poisson2_mesh.o, say. The driver code only needs to include the templated header file (which contains the class definition and the function prototypes) so that the first few lines of the modified driver code look like this: \dontinclude two_d_poisson2.cc \skipline Driver for \until meshes/simple The driver code can now be compiled separately (without having to recompile the mesh sources every time) and the correctly instantiated version of the \c SimpleRectangularQuadMesh can be made available by including \c two_d_poisson2_mesh.o during the linking phase. \subsection different_solvers How to choose the linear solver for the Newton method \c oomph-lib treats all problems as nonlinear problems and provides steady (and unsteady) Newton solvers to solve the system of nonlinear algebraic equations that arise from the spatial (and temporal) discretisation of the governing equations. Typically, the repeated assembly of the Jacobian matrix and the solution of the linear systems during the Newton iteration provides the major part of the computational work. Within this framework linear problems are simply special cases of nonlinear problems for which the Newton method converges in one iteration. The assembly of the Jacobian matrix and the solution of the linear system is performed by \c oomph-lib's \c LinearSolver objects. These typically provide interfaces to general purpose linear solvers such as \c SuperLUSolver (our default solver). The list of solvers includes: - \c SuperLUSolver: An interface to Demmel, Eistenstat, Gilbert, Li &amp; Liu's serial SuperLU solver. See &lt;A HREF=&quot;http: http: - \c HSL_MA42: An interface to the MA42 frontal solver from the HSL library. See &lt;A HREF=&quot;http: http: for details. - \c FD_LU: An extremely inefficient solver which computes the Jacobian matrix by finite differencing and stores it in a dense matrix. This solver is mainly provided to facilitate sanity checks during code development. (The residuals are easier to compute than the the Jacobian matrix!) - ...and many others. See the &lt;a href=&quot;../../../linear_solvers/html/index.html&quot;&gt;Linear Solvers Tutorial&lt;/a&gt; for a more detailed discussion of \c oomph-lib's various direct and iterative solvers. . By default the \c oomph-lib Newton solvers use \c SuperLU with compressed row storage for the Jacobian matrix as the linear solver. To change the linear solver to another type you can over-write the \c Problem's pointer to its linear solver. For instance, to change the linear solver to \c HSL_MA42, add the following lines to the \c Problem constructor: \code Problem::linear_solver_pt() = new HSL_MA42</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="two__d__poisson_8txt_source.html#l00408">408</a> of file <a class="el" href="two__d__poisson_8txt_source.html">two_d_poisson.txt</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adff9ced81c6476b852d5feaad9392c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff9ced81c6476b852d5feaad9392c1b">&#9670;&nbsp;</a></span>static_cast&lt; HSL_MA42 * &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static_cast&lt; HSL_MA42 * &gt; </td>
          <td>(</td>
          <td class="paramtype">Problem::linear_solver_pt()&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  doc_stats()=true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch on full doc for frontal solver. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4074baada03976c061d5672f4237cca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4074baada03976c061d5672f4237cca5">&#9670;&nbsp;</a></span>problem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mainpage Demo problem</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="two__d__poisson_8txt_source.html#l00002">2</a> of file <a class="el" href="two__d__poisson_8txt_source.html">two_d_poisson.txt</a>.</p>

<p class="reference">Referenced by <a class="el" href="two__d__poisson_8cc_source.html#l00271">main()</a>, and <a class="el" href="two__d__poisson__compare__solvers_8cc_source.html#l00317">run()</a>.</p>

</div>
</div>
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Fri Jul 9 2021 20:57:20
        </div>
      </div>
    </footer>
</body>
</html>
