\hypertarget{two__d__poisson_8txt}{}\doxysection{two\+\_\+d\+\_\+poisson.\+txt File Reference}
\label{two__d__poisson_8txt}\index{two\_d\_poisson.txt@{two\_d\_poisson.txt}}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{two__d__poisson_8txt_aa166dca8d99a7a36f016ae036351695c}{i}} = 1\}$^\wedge$2 \textbackslash{}frac\{\textbackslash{}partial$^\wedge$2u\}\{\textbackslash{}partial x\+\_\+i$^\wedge$2\}=f(x\+\_\+1, x\+\_\+2), \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} @E\mbox{[}2D\+Poisson\mbox{]}@ \textbackslash{}f\mbox{]} in the rectangular domain \textbackslash{}f \$D=\textbackslash{}left\textbackslash{}\{(x\+\_\+1, x\+\_\+2) \textbackslash{}in\mbox{[}0, 1\mbox{]} \textbackslash{}times\mbox{[}0, 2\mbox{]}\textbackslash{}right\textbackslash{}\}\textbackslash{}f\$, with Dirichlet boundary conditions \textbackslash{}f\mbox{[}\textbackslash{}left. u\textbackslash{}right$\vert$\+\_\+\{\textbackslash{}partial D\}=u\+\_\+0 \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} @E\mbox{[}2D\+Poisson\+\_\+\+BC\mbox{]}@ \textbackslash{}f\mbox{]} where the function \textbackslash{}f\$ u\+\_\+0 \textbackslash{}f\$ is given.$<$/TD $>$$<$/TR $>$$<$/T\+A\+B\+LE $>$$<$/C\+E\+N\+T\+ER $>$ We provide a detailed discussion of the driver code$<$ A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson.\+cc$<$/A $>$ which solves the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} for \textbackslash{}f\mbox{[}u\+\_\+0(x\+\_\+1, x\+\_\+2)=\textbackslash{}tanh(1-\/\textbackslash{}alpha(x\+\_\+1 \textbackslash{}tan\textbackslash{}\+Phi -\/ x\+\_\+2)), \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} @E\mbox{[}Exact\+Soln\mbox{]}@ \textbackslash{}f\mbox{]} and \textbackslash{}f\mbox{[}f(x\+\_\+1, x\+\_\+2)=\textbackslash{}sum\+\_\+\{\mbox{\hyperlink{two__d__poisson_8txt_aa166dca8d99a7a36f016ae036351695c}{i}}=1\}$^\wedge$2 \textbackslash{}frac\{\textbackslash{}partial$^\wedge$2 u\+\_\+0\}\{\textbackslash{}partial x\+\_\+i$^\wedge$2\}, \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} @E\mbox{[}Source\+Fct\mbox{]}@ \textbackslash{}f\mbox{]} so that \textbackslash{}f \$u\+\_\+0(x\+\_\+1, x\+\_\+2) \textbackslash{}f\$ represents the exact solution of the problem. For large values of \textbackslash{}f\$ \textbackslash{}alpha \textbackslash{}f\$ the solution approaches a step function \textbackslash{}f\mbox{[}u\+\_\+\{step\}(x\+\_\+1, x\+\_\+2)=\textbackslash{}left\textbackslash{}\{ \textbackslash{}begin\{array\}\{rl\} -\/1 \&\textbackslash{}mbox \{for \$x\+\_\+2$<$ x\+\_\+1 \textbackslash{} \textbackslash{}tan\textbackslash{}\+Phi\$\} \textbackslash{}\textbackslash{} 1 \&\textbackslash{}mbox \{for \$x\+\_\+2 $>$ x\+\_\+1 \textbackslash{} \textbackslash{}tan\textbackslash{}\+Phi\$\} \textbackslash{}end\{array\} \textbackslash{}right. \textbackslash{}f\mbox{]} which presents a serious challenge for any numerical method. The figure below compares the numerical and exact solutions for \textbackslash{}f\$ \textbackslash{}alpha=1 \textbackslash{}f\$ and \textbackslash{}f\$\textbackslash{}\+Phi=45$^\wedge$o\textbackslash{}f\$. @I w 0.\+75\textbackslash{}textwidth two\+\_\+d\+\_\+poisson\+\_\+soln \char`\"{}Plot of the solution \char`\"{}$<$ HR $>$$<$ HR $>$ \textbackslash{}section global Global parameters and functions Following our usual practice, we use a namespace, \textbackslash{}c Tanh\+Soln\+For\+Poisson, to define the source function( @R\mbox{[}Source\+Fct\mbox{]}@) and the exact solution( @R\mbox{[}Exact\+Soln\mbox{]}@). Both functions permit arbitrary values of the tangent \textbackslash{}f\$ \textbackslash{}tan \textbackslash{}Phi \textbackslash{}f\$ and the steepness parameter \textbackslash{}f\$ \textbackslash{}alpha \textbackslash{}f\$, which are stored in \mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{Tanh\+Soln\+For\+Poisson\+::\+Tan\+Phi}} and \mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Tanh\+Soln\+For\+Poisson\+::\+Alpha}}, respectively, so that the \char`\"{}user\char`\"{} can set their values from the driver code. \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson.\+cc \textbackslash{}skipline start\+\_\+of\+\_\+namespace \textbackslash{}until end of namespace$<$ HR $>$$<$ HR $>$ \textbackslash{}section \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}} The driver code In order to solve the 2D Poisson \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} using \textbackslash{}c oomph-\/lib, we represent the mathematical \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} defined by equations( @R\mbox{[}2D\+Poisson\mbox{]}@) and( @R\mbox{[}2D\+Poisson\+\_\+\+BC\mbox{]}@) in a specific \textbackslash{}c Problem object, \textbackslash{}c Poisson\+Problem. \textbackslash{}c oomph-\/lib provides a variety of 2D Poisson elements(e.\+g. 2D quadrilateral elements with bi-\/linear, bi-\/quadratic and bi-\/cubic representations for the unknown function) and we pass the specific element type as a template parameter to the \textbackslash{}c Problem. In the driver code, listed below, we use the \textbackslash{}c Q\+Poisson\+Element$<$ 2, 3 $>$, a nine-\/node(bi-\/quadratic) 2D Poisson element. The next few lines of the \textbackslash{}c \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}() function create a \textbackslash{}c Doc\+Info object -\/-\/ an \textbackslash{}c oomph-\/lib object that collates various items of data that can be used to label output files\+:\+Here we specify that the output files are to be written to the directory \char`\"{}R\+E\+S\+LT\char`\"{}, and that the first batch of output files should be labelled with the identifier \char`\"{}0\char`\"{}. See the discussion of the postprocessing routine \textbackslash{}c doc\+\_\+solution(...) for details.\mbox{[}\textbackslash{}b Note\+:\+While the ability to specify an output directory from the driver code is useful, it does rely on the \char`\"{}user\char`\"{} having created the directory before the code is executed. We could use the C++\textbackslash{}c system(...) function to issue a system command which creates the directory if it does not exist. Since this would make the code non-\/portable, we only issue a warning suggesting the likely cause of the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} if the output file cannot be opened. If you want to make absolutely sure that the output directory does exist and can be written to, you can change this forgiving behaviour with the function \textbackslash{}c Doc\+Info\+::directory\+\_\+must\+\_\+exist(). This function provides access to a boolean flag which is set to \textbackslash{}c false by default. If set to \textbackslash{}c true, the code execution terminates with \textbackslash{}c assert(false) if the directory specified with \textbackslash{}c Doc\+Info\+::set\+\_\+directory(...) cannot be written to.\mbox{]} Next we execute the \textbackslash{}c Problem\+::self\+\_\+test() function to check whether the \textbackslash{}c Problem has been correctly initialised. If this test is passed, we proceed to the solution. We choose the angle of the \char`\"{}step\char`\"{} as 45 degrees(corresponding to \textbackslash{}f\$ \textbackslash{}tan \textbackslash{}Phi=1 \textbackslash{}f\$) and then solve the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} for a number of values of the steepness parameter \textbackslash{}f\$ \textbackslash{}alpha. \textbackslash{}f\$ We document each solution with the post-\/processing routine \textbackslash{}c doc\+\_\+solution(...) which accesses the step number and the output directory via the \textbackslash{}c Doc\+Info object. \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson.\+cc \textbackslash{}skipline start\+\_\+of\+\_\+main \textbackslash{}until end of \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}$<$ HR $>$$<$ HR $>$ \textbackslash{}section \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} The \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} class The \textbackslash{}c \mbox{\hyperlink{classPoissonProblem}{Poisson\+Problem}} is derived from \textbackslash{}c oomph-\/lib \textquotesingle{}s generic \textbackslash{}c Problem class and the specific element type is specified as a template parameter to make it easy for the \char`\"{}user\char`\"{} to change the element type from the driver code. \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson.\+cc \textbackslash{}skipline start\+\_\+of\+\_\+problem\+\_\+class \textbackslash{}until public Problem The \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} class has five member functions, only three of which are non-\/trivial\+:-\/ the constructor \textbackslash{}c \mbox{\hyperlink{classPoissonProblem}{Poisson\+Problem}}(...) -\/ the function \textbackslash{}c actions\+\_\+before\+\_\+newton\+\_\+solve() -\/ the function \textbackslash{}c doc\+\_\+solution(...) . The function \textbackslash{}c Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve() is a pure virtual member function of the \textbackslash{}c Problem base class and must be provided. However, it is not required in the present \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} and we leave it empty. Similarly, the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} destructor can remain empty as all memory de-\/allocation is handled in the destructor of the \textbackslash{}c Problem base class. The Problem only stores one private data member, the pointer to the source function. \textbackslash{}skipline public\+:\textbackslash{}until end of \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} class\mbox{[}See the discussion of the$<$ A H\+R\+EF=\char`\"{}../../../poisson/one\+\_\+d\+\_\+poisson/html/index.\+html\char`\"{}$>$ 1D Poisson \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}}$<$/A $>$ for a more detailed discussion of the function type Poisson\+Equations$<$ 2 $>$\+::Poisson\+Source\+Fct\+Pt.\mbox{]}$<$ HR $>$$<$ HR $>$ \textbackslash{}section constructor The Problem constructor In the \textbackslash{}c Problem constructor, we start by discretising the rectangular domain, using \textbackslash{}c oomph-\/lib \textquotesingle{}s \textbackslash{}c Simple\+Rectangular\+Quad\+Mesh object. The arguments of this object \textquotesingle{}s constructor are the number of elements(whose type is specified by the template parameter), and the domain lengths in the \textbackslash{}f \$x\+\_\+1 \textbackslash{}f\$ and \textbackslash{}f \$x\+\_\+2 \textbackslash{}f\$ directions, respectively. The subsequent lines of code pin the nodal values along the entire domain boundary. In the$<$ A H\+R\+EF=\char`\"{}../../../poisson/one\+\_\+d\+\_\+poisson/html/index.\+html\char`\"{}$>$ 1D example$<$/A $>$ considered earlier, the identification of the nodes on the domain boundaries was trivial. In higher-\/dimensional problems, this task can become rather involved. \textbackslash{}c oomph-\/lib \textquotesingle{}s \textbackslash{}c Mesh base class provides the helper function \textbackslash{}c Mesh\+::boundary\+\_\+node\+\_\+pt(...) giving(pointer-\/based) access to nodes on specified mesh boundaries.\mbox{[}The total number of boundaries can be obtained from \textbackslash{}c Mesh\+::nboundary(), while the number of nodes on a specific boundary is available from \textbackslash{}c Mesh\+::nboundary\+\_\+node(...).\mbox{]} The nested loops over the mesh boundaries and the nodes on these boundaries therefore provide a convenient and completely generic method of accessing all boundary nodes. Finally we loop over all elements to assign the source function pointer, and then call the generic \textbackslash{}c Problem\+::assign\+\_\+eqn\+\_\+numbers() routine to set up the equation numbers. \textbackslash{}skipline start\+\_\+of\+\_\+constructor \textbackslash{}until end of constructor$<$ HR $>$$<$ HR $>$ \textbackslash{}section actions\+\_\+before \char`\"{}Actions before solve\char`\"{} We use \textbackslash{}c Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve() to update the boundary conditions in response to possible changes in the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} parameters. We use the exact solution, specified in \textbackslash{}c \mbox{\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{Tanh\+Soln\+For\+Poisson\+::get\+\_\+exact\+\_\+u}}(...), to determine the boundary values that are appropriate for the current values of \textbackslash{}f\$ \textbackslash{}alpha \textbackslash{}f\$ and \textbackslash{}f\$ \textbackslash{}tan \textbackslash{}Phi \textbackslash{}f\$. \textbackslash{}skipline start\+\_\+of\+\_\+actions\+\_\+before\+\_\+newton\+\_\+solve \textbackslash{}until end of actions before solve\mbox{[}See the discussion of the$<$ A H\+R\+EF=\char`\"{}../../../poisson 1D Poisson \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}}$<$/A$>$ for a more detailed discussion of the pure virtual functions \textbackslash{}c Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve() and \textbackslash{}c Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve().\mbox{]} $<$HR$>$ $<$HR$>$ \textbackslash{}section doc Post-\/processing The function \textbackslash{}c doc\+\_\+solution(...) writes the FE solution and the corresponding exact solution, defined in \textbackslash{}c \mbox{\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{Tanh\+Soln\+For\+Poisson\+::get\+\_\+exact\+\_\+u}}(...) to disk. The \textbackslash{}c Doc\+Info object specifies the output directory and the label for the file names. \mbox{[}See the discussion of the $<$A H\+R\+EF=\char`\"{}../../../poisson/one\+\_\+d\+\_\+poisson/html/index.\+html\char`\"{}$>$ 1D Poisson \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}}$<$/A$>$ for a more detailed discussion of the generic \textbackslash{}c Mesh member functions \textbackslash{}c Mesh\+::output(...), \textbackslash{}c Mesh\+::output\+\_\+fct(...) and \textbackslash{}c Mesh\+::compute\+\_\+error(...)\mbox{]}. \textbackslash{}skipline start\+\_\+of\+\_\+doc \textbackslash{}until end of doc $<$HR$>$ $<$HR$>$ \textbackslash{}section exercises Comments and exercises -\/\# In its current form, the number of elements and the dimensions of the domain are hard-\/coded in the \textbackslash{}c Problem constructor. Change the \textbackslash{}c Problem constructor so that these quantities become input parameters that can be set from the \textbackslash{}c \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}() function. -\/\# Note how the accuracy of the FE solution decreases as the steepness of the \char`\"{}step\char`\"{} is increased\+: @I w 0.\+75\textbackslash{}textwidth alpha \char`\"{}Plot of the solution for different values of the steepness parameter \char`\"{} How many elements are required to resolve the solution with \textbackslash{}f\$ \textbackslash{}alpha = 10 \textbackslash{}f\$ as accurately as in the case of \textbackslash{}f\$ \textbackslash{}alpha = 1\textbackslash{}f\$? \mbox{[}\textbackslash{}b Note\+: Since the solution has steep gradients only in a very narrow region, uniform mesh refinement is an extremely wasteful method of improving the accuracy of the computed solution. \textbackslash{}c oomph-\/lib provides powerful mesh adaptation routines which perform fully-\/automatic mesh refinement and unrefinement, based on a posteriori error estimates of the solution. We will demonstrate these in $<$A H\+R\+EF=\char`\"{}../../../poisson/fish\+\_\+poisson/html/index.\+html\char`\"{}$>$ another example.$<$/A$>$\mbox{]} -\/\# Repeat the numerical experiments with different element types. Replace the nine-\/node Poisson element, \textbackslash{}c Q\+Poisson\+Element$<$2,3$>$, by its lower-\/ and higher-\/order counterparts \textbackslash{}c Q\+Poisson\+Element$<$2,2$>$ and \textbackslash{}c Q\+Poisson\+Element$<$2,4$>$, respectively. Compare the total number of degrees of freedom, the errors, and the \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_a23bdfecb707db57cd809897a41b71297}{run}}-\/times for the different discretisations. \textbackslash{}subsection precompile\+\_\+mesh Header files and precompiled meshes We have repeatedly stressed that \textbackslash{}c oomph-\/lib \textbackslash{}c Mesh objects are (and any user-\/written ones should be) templated by the element type, so that meshes can be used with all finite elements that are derived from the same geometric element (2D quad elements from the \textbackslash{}c Q\+Element family, say). Typically, the element type is specified in the driver code. Consequently, the compiler must instantiate the \textbackslash{}c Mesh object for a particular element type when the driver code is compiled -\/-\/ there is no point in trying to \char`\"{}pre-\/compile\char`\"{} a \textbackslash{}c Mesh object for \char`\"{}all possible element types\char`\"{}. The source code for \textbackslash{}c Mesh objects is therefore usually contained in a single (header) file which must be included in the driver code. The first few lines of the driver code $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson.\+cc$<$/A$>$ illustrate the technique\+: \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson.\+cc \textbackslash{}skipline Driver for \textbackslash{}until meshes/simple The code uses objects from the \textbackslash{}c generic and \textbackslash{}c poisson libraries whose function prototypes are contained in the header files \textbackslash{}c generic.\+h and \textbackslash{}c poisson.\+h, located in the \textbackslash{}c oomph-\/lib \textbackslash{}c include directory. All objects in these libraries are fully instantiated and no re-\/compilation is required -\/-\/ we simply link against the libraries which are located in \textbackslash{}c oomph-\/lib\textquotesingle{}s \textbackslash{}c lib directory. The mesh header files (which include the entire source code for each mesh) are located in the include (sub-\/)directory \textbackslash{}c include/meshes, and are included into the driver code with a C++ include directive While this strategy greatly facilitates code reuse, it can incur significant compile-\/time overheads as the (possibly very lengthy) mesh sources must be recompiled whenever the driver code is changed. During code development, this overhead can become unacceptable. To avoid the constant re-\/compilation of the mesh sources, all \textbackslash{}c oomph-\/lib mesh objects are contained in two separate source files. In the case of the \textbackslash{}c Simple\+Rectangular\+Mesh, the class definition and function prototypes are contained in the small auxiliary header file \textbackslash{}c simple\+\_\+rectangular\+\_\+quadmesh.\+template.\+h, while the actual function definitions are contained in \textbackslash{}c simple\+\_\+rectangular\+\_\+quadmesh.\+template.\+cc. These are the only sources that the mesh-\/writer has to provide. The header file \textbackslash{}c simple\+\_\+rectangular\+\_\+quadmesh.\+h is generated (automatically) by concatenating the two $\ast$.template.$\ast$ files and all three files are contained in the mesh include directory. This allows the \char`\"{}user\char`\"{} to pre-\/compile the mesh for a specific element type (or for a range of specific elements) to produce a separate object file that can be linked against when the driver code is built. The procedure is illustrated in the alternative source code $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson2.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson2.\+cc$<$/A$>$ and the associated mesh file, $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc$<$/A$>$. In the original version of the code, $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson.\+cc$<$/A$>$, the mesh was instantiated with the element type \textbackslash{}c Q\+Poisson\+Element$<$2,3$>$ and we will assume that this is the only element type required in the driver code. We force the instantiation of the \textbackslash{}c Simple\+Rectangular\+Quad\+Mesh for this element type by employing the C++ \char`\"{}template\char`\"{} statement in the mesh file, $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc$<$/A$>$, which is listed in its entirety here\+: \textbackslash{}include two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc This source file can be pre-\/compiled into an object file, \textbackslash{}c two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+o, say. The driver code only needs to include the templated header file (which contains the class definition and the function prototypes) so that the first few lines of the modified driver code look like this\+: \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson2.\+cc \textbackslash{}skipline Driver for \textbackslash{}until meshes/simple The driver code can now be compiled separately (without having to recompile the mesh sources every time) and the correctly instantiated version of the \textbackslash{}c Simple\+Rectangular\+Quad\+Mesh can be made available by including \textbackslash{}c two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+o during the linking phase. \textbackslash{}subsection different\+\_\+solvers How to choose the linear solver for the Newton method \textbackslash{}c oomph-\/lib treats all problems as nonlinear problems and provides steady (and unsteady) Newton solvers to solve the system of nonlinear algebraic equations that arise from the spatial (and temporal) discretisation of the governing equations. Typically, the repeated assembly of the Jacobian matrix and the solution of the linear systems during the Newton iteration provides the major part of the computational work. Within this framework linear problems are simply special cases of nonlinear problems for which the Newton method converges in one iteration. The assembly of the Jacobian matrix and the solution of the linear system is performed by \textbackslash{}c oomph-\/lib\textquotesingle{}s \textbackslash{}c Linear\+Solver objects. These typically provide interfaces to general purpose linear solvers such as \textbackslash{}c Super\+L\+U\+Solver (our default solver). The list of solvers includes\+: -\/ \textbackslash{}c Super\+L\+U\+Solver\+: An interface to Demmel, Eistenstat, Gilbert, Li \& Liu\textquotesingle{}s serial Super\+LU solver. See $<$A H\+R\+EF=\char`\"{}http\+:http\+:-\/ \textbackslash{}c H\+S\+L\+\_\+\+M\+A42\+:\+An interface to the M\+A42 frontal solver from the H\+SL library. See$<$ A H\+R\+EF=\char`\"{}http\+: http\+: for details. -\/ \textbackslash{}c F\+D\+\_\+\+L\+U\+: An extremely inefficient solver which computes the Jacobian matrix by finite differencing and stores it in a dense matrix. This solver is mainly provided to facilitate sanity checks during code development. (The residuals are easier to compute than the the Jacobian matrix!) -\/ ...and many others. See the $<$a href=\char`\"{}../../../linear\+\_\+solvers/html/index.\+html\char`\"{}$>$Linear Solvers Tutorial$<$/a$>$ for a more detailed discussion of \textbackslash{}c oomph-\/lib\textquotesingle{}s various direct and iterative solvers. . By default the \textbackslash{}c oomph-\/lib Newton solvers use \textbackslash{}c Super\+LU with compressed row storage for the Jacobian matrix as the linear solver. To change the linear solver to another type you can over-\/write the \textbackslash{}c Problem\textquotesingle{}s pointer to its linear solver. For instance, to change the linear solver to \textbackslash{}c H\+S\+L\+\_\+\+M\+A42, add the following lines to the \textbackslash{}c Problem constructor\+: \textbackslash{}code Problem\+::linear\+\_\+solver\+\_\+pt() = new H\+S\+L\+\_\+\+M\+A42
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{two__d__poisson_8txt_adff9ced81c6476b852d5feaad9392c1b}{static\+\_\+cast$<$ H\+S\+L\+\_\+\+M\+A42 $\ast$ $>$}} (Problem\+::linear\+\_\+solver\+\_\+pt()) -\/$>$ doc\+\_\+stats()=true
\begin{DoxyCompactList}\small\item\em Switch on full doc for frontal solver. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
mainpage Demo \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}}
\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{two__d__poisson_8txt_aa166dca8d99a7a36f016ae036351695c}\label{two__d__poisson_8txt_aa166dca8d99a7a36f016ae036351695c}} 
\index{two\_d\_poisson.txt@{two\_d\_poisson.txt}!i@{i}}
\index{i@{i}!two\_d\_poisson.txt@{two\_d\_poisson.txt}}
\doxysubsubsection{\texorpdfstring{i}{i}}
{\footnotesize\ttfamily using \mbox{\hyperlink{two__d__poisson_8txt_aa166dca8d99a7a36f016ae036351695c}{i}} =  1\}$^\wedge$2 \textbackslash{}frac\{\textbackslash{}partial$^\wedge$2u\}\{\textbackslash{}partial x\+\_\+i$^\wedge$2\} = f(x\+\_\+1,x\+\_\+2), \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} @E\mbox{[}2D\+Poisson\mbox{]}@ \textbackslash{}f\mbox{]} in the rectangular domain \textbackslash{}f\$D =\textbackslash{}left\textbackslash{}\{ (x\+\_\+1,x\+\_\+2) \textbackslash{}in \mbox{[}0,1\mbox{]} \textbackslash{}times \mbox{[}0,2\mbox{]}\textbackslash{}right\textbackslash{}\}\textbackslash{}f\$, with Dirichlet boundary conditions \textbackslash{}f\mbox{[} \textbackslash{}left. u\textbackslash{}right$\vert$\+\_\+\{\textbackslash{}partial D\}=u\+\_\+0 \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} @E\mbox{[}2D\+Poisson\+\_\+\+BC\mbox{]}@ \textbackslash{}f\mbox{]} where the function \textbackslash{}f\$ u\+\_\+0 \textbackslash{}f\$ is given. $<$/TD$>$ $<$/TR$>$ $<$/T\+A\+B\+LE$>$ $<$/C\+E\+N\+T\+ER$>$ We provide a detailed discussion of the driver code $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson.\+cc$<$/A$>$ which solves the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} for \textbackslash{}f\mbox{[} u\+\_\+0(x\+\_\+1,x\+\_\+2) = \textbackslash{}tanh(1-\/\textbackslash{}alpha(x\+\_\+1 \textbackslash{}tan\textbackslash{}\+Phi -\/ x\+\_\+2)), \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} @E\mbox{[}Exact\+Soln\mbox{]}@ \textbackslash{}f\mbox{]} and \textbackslash{}f\mbox{[} f(x\+\_\+1,x\+\_\+2) = \textbackslash{}sum\+\_\+\{\mbox{\hyperlink{two__d__poisson_8txt_aa166dca8d99a7a36f016ae036351695c}{i}}=1\}$^\wedge$2 \textbackslash{}frac\{\textbackslash{}partial$^\wedge$2 u\+\_\+0\}\{\textbackslash{}partial x\+\_\+i$^\wedge$2\}, \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} \textbackslash{} @E\mbox{[}Source\+Fct\mbox{]}@ \textbackslash{}f\mbox{]} so that \textbackslash{}f\$u\+\_\+0(x\+\_\+1,x\+\_\+2) \textbackslash{}f\$ represents the exact solution of the problem. For large values of \textbackslash{}f\$ \textbackslash{}alpha \textbackslash{}f\$ the solution approaches a step function \textbackslash{}f\mbox{[} u\+\_\+\{step\}(x\+\_\+1,x\+\_\+2) = \textbackslash{}left\textbackslash{}\{ \textbackslash{}begin\{array\}\{rl\} -\/1 \& \textbackslash{}mbox \{for \$x\+\_\+2 $<$ x\+\_\+1 \textbackslash{} \textbackslash{}tan\textbackslash{}\+Phi\$\} \textbackslash{}\textbackslash{} 1 \& \textbackslash{}mbox \{for \$x\+\_\+2 $>$ x\+\_\+1 \textbackslash{} \textbackslash{}tan\textbackslash{}\+Phi\$\} \textbackslash{}end\{array\} \textbackslash{}right. \textbackslash{}f\mbox{]} which presents a serious challenge for any numerical method. The figure below compares the numerical and exact solutions for \textbackslash{}f\$ \textbackslash{}alpha = 1 \textbackslash{}f\$ and \textbackslash{}f\$\textbackslash{}\+Phi = 45$^\wedge$o\textbackslash{}f\$. @I w 0.\+75\textbackslash{}textwidth two\+\_\+d\+\_\+poisson\+\_\+soln \char`\"{}Plot of the solution \char`\"{} $<$HR$>$ $<$HR$>$ \textbackslash{}section global Global parameters and functions Following our usual practice, we use a namespace, \textbackslash{}c Tanh\+Soln\+For\+Poisson, to define the source function (@R\mbox{[}Source\+Fct\mbox{]}@) and the exact solution (@R\mbox{[}Exact\+Soln\mbox{]}@). Both functions permit arbitrary values of the tangent \textbackslash{}f\$ \textbackslash{}tan \textbackslash{}Phi \textbackslash{}f\$ and the steepness parameter \textbackslash{}f\$ \textbackslash{}alpha \textbackslash{}f\$, which are stored in \mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{Tanh\+Soln\+For\+Poisson\+::\+Tan\+Phi}} and \mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Tanh\+Soln\+For\+Poisson\+::\+Alpha}}, respectively, so that the \char`\"{}user\char`\"{} can set their values from the driver code. \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson.\+cc \textbackslash{}skipline start\+\_\+of\+\_\+namespace \textbackslash{}until end of namespace $<$HR$>$ $<$HR$>$ \textbackslash{}section \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}} The driver code In order to solve the 2D Poisson \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} using \textbackslash{}c oomph-\/lib, we represent the mathematical \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} defined by equations (@R\mbox{[}2D\+Poisson\mbox{]}@) and (@R\mbox{[}2D\+Poisson\+\_\+\+BC\mbox{]}@) in a specific \textbackslash{}c Problem object, \textbackslash{}c Poisson\+Problem. \textbackslash{}c oomph-\/lib provides a variety of 2D Poisson elements (e.\+g. 2D quadrilateral elements with bi-\/linear, bi-\/quadratic and bi-\/cubic representations for the unknown function) and we pass the specific element type as a template parameter to the \textbackslash{}c Problem. In the driver code, listed below, we use the \textbackslash{}c Q\+Poisson\+Element$<$2,3$>$, a nine-\/node (bi-\/quadratic) 2D Poisson element. The next few lines of the \textbackslash{}c \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}() function create a \textbackslash{}c Doc\+Info object -\/-\/ an \textbackslash{}c oomph-\/lib object that collates various items of data that can be used to label output files\+: Here we specify that the output files are to be written to the directory \char`\"{}R\+E\+S\+LT\char`\"{}, and that the first batch of output files should be labelled with the identifier \char`\"{}0\char`\"{}. See the discussion of the postprocessing routine \textbackslash{}c doc\+\_\+solution(...) for details. \mbox{[}\textbackslash{}b Note\+: While the ability to specify an output directory from the driver code is useful, it does rely on the \char`\"{}user\char`\"{} having created the directory before the code is executed. We could use the C++ \textbackslash{}c system(...) function to issue a system command which creates the directory if it does not exist. Since this would make the code non-\/portable, we only issue a warning suggesting the likely cause of the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} if the output file cannot be opened. If you want to make absolutely sure that the output directory does exist and can be written to, you can change this forgiving behaviour with the function \textbackslash{}c Doc\+Info\+::directory\+\_\+must\+\_\+exist(). This function provides access to a boolean flag which is set to \textbackslash{}c false by default. If set to \textbackslash{}c true, the code execution terminates with \textbackslash{}c assert(false) if the directory specified with \textbackslash{}c Doc\+Info\+::set\+\_\+directory(...) cannot be written to.\mbox{]} Next we execute the \textbackslash{}c Problem\+::self\+\_\+test() function to check whether the \textbackslash{}c Problem has been correctly initialised. If this test is passed, we proceed to the solution. We choose the angle of the \char`\"{}step\char`\"{} as 45 degrees (corresponding to \textbackslash{}f\$ \textbackslash{}tan \textbackslash{}Phi = 1 \textbackslash{}f\$) and then solve the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} for a number of values of the steepness parameter \textbackslash{}f\$ \textbackslash{}alpha. \textbackslash{}f\$ We document each solution with the post-\/processing routine \textbackslash{}c doc\+\_\+solution(...) which accesses the step number and the output directory via the \textbackslash{}c Doc\+Info object. \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson.\+cc \textbackslash{}skipline start\+\_\+of\+\_\+main \textbackslash{}until end of \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}} $<$HR$>$ $<$HR$>$ \textbackslash{}section \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} The \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} class The \textbackslash{}c \mbox{\hyperlink{classPoissonProblem}{Poisson\+Problem}} is derived from \textbackslash{}c oomph-\/lib\textquotesingle{}s generic \textbackslash{}c Problem class and the specific element type is specified as a template parameter to make it easy for the \char`\"{}user\char`\"{} to change the element type from the driver code. \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson.\+cc \textbackslash{}skipline start\+\_\+of\+\_\+problem\+\_\+class \textbackslash{}until public Problem The \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} class has five member functions, only three of which are non-\/trivial\+: -\/ the constructor \textbackslash{}c \mbox{\hyperlink{classPoissonProblem}{Poisson\+Problem}}(...) -\/ the function \textbackslash{}c actions\+\_\+before\+\_\+newton\+\_\+solve() -\/ the function \textbackslash{}c doc\+\_\+solution(...) . The function \textbackslash{}c Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve() is a pure virtual member function of the \textbackslash{}c Problem base class and must be provided. However, it is not required in the present \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} and we leave it empty. Similarly, the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} destructor can remain empty as all memory de-\/allocation is handled in the destructor of the \textbackslash{}c Problem base class. The Problem only stores one private data member, the pointer to the source function. \textbackslash{}skipline public\+: \textbackslash{}until end of \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} class \mbox{[}See the discussion of the $<$A H\+R\+EF=\char`\"{}../../../poisson/one\+\_\+d\+\_\+poisson/html/index.\+html\char`\"{}$>$ 1D Poisson \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}}$<$/A$>$ for a more detailed discussion of the function type Poisson\+Equations$<$2$>$\+::Poisson\+Source\+Fct\+Pt.\mbox{]} $<$HR$>$ $<$HR$>$ \textbackslash{}section constructor The Problem constructor In the \textbackslash{}c Problem constructor, we start by discretising the rectangular domain, using \textbackslash{}c oomph-\/lib\textquotesingle{}s \textbackslash{}c Simple\+Rectangular\+Quad\+Mesh object. The arguments of this object\textquotesingle{}s constructor are the number of elements (whose type is specified by the template parameter), and the domain lengths in the \textbackslash{}f\$x\+\_\+1 \textbackslash{}f\$ and \textbackslash{}f\$x\+\_\+2 \textbackslash{}f\$ directions, respectively. The subsequent lines of code pin the nodal values along the entire domain boundary. In the $<$A H\+R\+EF=\char`\"{}../../../poisson/one\+\_\+d\+\_\+poisson/html/index.\+html\char`\"{}$>$ 1D example$<$/A$>$ considered earlier, the identification of the nodes on the domain boundaries was trivial. In higher-\/dimensional problems, this task can become rather involved. \textbackslash{}c oomph-\/lib\textquotesingle{}s \textbackslash{}c Mesh base class provides the helper function \textbackslash{}c Mesh\+::boundary\+\_\+node\+\_\+pt(...) giving (pointer-\/based) access to nodes on specified mesh boundaries. \mbox{[}The total number of boundaries can be obtained from \textbackslash{}c Mesh\+::nboundary(), while the number of nodes on a specific boundary is available from \textbackslash{}c Mesh\+::nboundary\+\_\+node(...).\mbox{]} The nested loops over the mesh boundaries and the nodes on these boundaries therefore provide a convenient and completely generic method of accessing all boundary nodes. Finally we loop over all elements to assign the source function pointer, and then call the generic \textbackslash{}c Problem\+::assign\+\_\+eqn\+\_\+numbers() routine to set up the equation numbers. \textbackslash{}skipline start\+\_\+of\+\_\+constructor \textbackslash{}until end of constructor $<$HR$>$ $<$HR$>$ \textbackslash{}section actions\+\_\+before \char`\"{}Actions before solve\char`\"{} We use \textbackslash{}c Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve() to update the boundary conditions in response to possible changes in the \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}} parameters. We use the exact solution, specified in \textbackslash{}c \mbox{\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{Tanh\+Soln\+For\+Poisson\+::get\+\_\+exact\+\_\+u}}(...), to determine the boundary values that are appropriate for the current values of \textbackslash{}f\$ \textbackslash{}alpha \textbackslash{}f\$ and \textbackslash{}f\$ \textbackslash{}tan \textbackslash{}Phi \textbackslash{}f\$. \textbackslash{}skipline start\+\_\+of\+\_\+actions\+\_\+before\+\_\+newton\+\_\+solve \textbackslash{}until end of actions before solve \mbox{[}See the discussion of the $<$A H\+R\+EF=\char`\"{}../../../poisson 1D Poisson \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}}$<$/A$>$ for a more detailed discussion of the pure virtual functions \textbackslash{}c Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve() and \textbackslash{}c Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve().\mbox{]} $<$HR$>$ $<$HR$>$ \textbackslash{}section doc Post-\/processing The function \textbackslash{}c doc\+\_\+solution(...) writes the FE solution and the corresponding exact solution, defined in \textbackslash{}c \mbox{\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{Tanh\+Soln\+For\+Poisson\+::get\+\_\+exact\+\_\+u}}(...) to disk. The \textbackslash{}c Doc\+Info object specifies the output directory and the label for the file names. \mbox{[}See the discussion of the $<$A H\+R\+EF=\char`\"{}../../../poisson/one\+\_\+d\+\_\+poisson/html/index.\+html\char`\"{}$>$ 1D Poisson \mbox{\hyperlink{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}{problem}}$<$/A$>$ for a more detailed discussion of the generic \textbackslash{}c Mesh member functions \textbackslash{}c Mesh\+::output(...), \textbackslash{}c Mesh\+::output\+\_\+fct(...) and \textbackslash{}c Mesh\+::compute\+\_\+error(...)\mbox{]}. \textbackslash{}skipline start\+\_\+of\+\_\+doc \textbackslash{}until end of doc $<$HR$>$ $<$HR$>$ \textbackslash{}section exercises Comments and exercises -\/\# In its current form, the number of elements and the dimensions of the domain are hard-\/coded in the \textbackslash{}c Problem constructor. Change the \textbackslash{}c Problem constructor so that these quantities become input parameters that can be set from the \textbackslash{}c \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}() function. -\/\# Note how the accuracy of the FE solution decreases as the steepness of the \char`\"{}step\char`\"{} is increased\+: @I w 0.\+75\textbackslash{}textwidth alpha \char`\"{}Plot of the solution for different values of the steepness parameter \char`\"{} How many elements are required to resolve the solution with \textbackslash{}f\$ \textbackslash{}alpha = 10 \textbackslash{}f\$ as accurately as in the case of \textbackslash{}f\$ \textbackslash{}alpha = 1\textbackslash{}f\$? \mbox{[}\textbackslash{}b Note\+: Since the solution has steep gradients only in a very narrow region, uniform mesh refinement is an extremely wasteful method of improving the accuracy of the computed solution. \textbackslash{}c oomph-\/lib provides powerful mesh adaptation routines which perform fully-\/automatic mesh refinement and unrefinement, based on a posteriori error estimates of the solution. We will demonstrate these in $<$A H\+R\+EF=\char`\"{}../../../poisson/fish\+\_\+poisson/html/index.\+html\char`\"{}$>$ another example.$<$/A$>$\mbox{]} -\/\# Repeat the numerical experiments with different element types. Replace the nine-\/node Poisson element, \textbackslash{}c Q\+Poisson\+Element$<$2,3$>$, by its lower-\/ and higher-\/order counterparts \textbackslash{}c Q\+Poisson\+Element$<$2,2$>$ and \textbackslash{}c Q\+Poisson\+Element$<$2,4$>$, respectively. Compare the total number of degrees of freedom, the errors, and the \mbox{\hyperlink{two__d__poisson__compare__solvers_8cc_a23bdfecb707db57cd809897a41b71297}{run}}-\/times for the different discretisations. \textbackslash{}subsection precompile\+\_\+mesh Header files and precompiled meshes We have repeatedly stressed that \textbackslash{}c oomph-\/lib \textbackslash{}c Mesh objects are (and any user-\/written ones should be) templated by the element type, so that meshes can be used with all finite elements that are derived from the same geometric element (2D quad elements from the \textbackslash{}c Q\+Element family, say). Typically, the element type is specified in the driver code. Consequently, the compiler must instantiate the \textbackslash{}c Mesh object for a particular element type when the driver code is compiled -\/-\/ there is no point in trying to \char`\"{}pre-\/compile\char`\"{} a \textbackslash{}c Mesh object for \char`\"{}all possible element types\char`\"{}. The source code for \textbackslash{}c Mesh objects is therefore usually contained in a single (header) file which must be included in the driver code. The first few lines of the driver code $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson.\+cc$<$/A$>$ illustrate the technique\+: \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson.\+cc \textbackslash{}skipline Driver for \textbackslash{}until meshes/simple The code uses objects from the \textbackslash{}c generic and \textbackslash{}c poisson libraries whose function prototypes are contained in the header files \textbackslash{}c generic.\+h and \textbackslash{}c poisson.\+h, located in the \textbackslash{}c oomph-\/lib \textbackslash{}c include directory. All objects in these libraries are fully instantiated and no re-\/compilation is required -\/-\/ we simply link against the libraries which are located in \textbackslash{}c oomph-\/lib\textquotesingle{}s \textbackslash{}c lib directory. The mesh header files (which include the entire source code for each mesh) are located in the include (sub-\/)directory \textbackslash{}c include/meshes, and are included into the driver code with a C++ include directive While this strategy greatly facilitates code reuse, it can incur significant compile-\/time overheads as the (possibly very lengthy) mesh sources must be recompiled whenever the driver code is changed. During code development, this overhead can become unacceptable. To avoid the constant re-\/compilation of the mesh sources, all \textbackslash{}c oomph-\/lib mesh objects are contained in two separate source files. In the case of the \textbackslash{}c Simple\+Rectangular\+Mesh, the class definition and function prototypes are contained in the small auxiliary header file \textbackslash{}c simple\+\_\+rectangular\+\_\+quadmesh.\+template.\+h, while the actual function definitions are contained in \textbackslash{}c simple\+\_\+rectangular\+\_\+quadmesh.\+template.\+cc. These are the only sources that the mesh-\/writer has to provide. The header file \textbackslash{}c simple\+\_\+rectangular\+\_\+quadmesh.\+h is generated (automatically) by concatenating the two $\ast$.template.$\ast$ files and all three files are contained in the mesh include directory. This allows the \char`\"{}user\char`\"{} to pre-\/compile the mesh for a specific element type (or for a range of specific elements) to produce a separate object file that can be linked against when the driver code is built. The procedure is illustrated in the alternative source code $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson2.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson2.\+cc$<$/A$>$ and the associated mesh file, $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc$<$/A$>$. In the original version of the code, $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson.\+cc$<$/A$>$, the mesh was instantiated with the element type \textbackslash{}c Q\+Poisson\+Element$<$2,3$>$ and we will assume that this is the only element type required in the driver code. We force the instantiation of the \textbackslash{}c Simple\+Rectangular\+Quad\+Mesh for this element type by employing the C++ \char`\"{}template\char`\"{} statement in the mesh file, $<$A H\+R\+EF=\char`\"{}../../../../demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson/two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc\char`\"{}$>$ two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc$<$/A$>$, which is listed in its entirety here\+: \textbackslash{}include two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+cc This source file can be pre-\/compiled into an object file, \textbackslash{}c two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+o, say. The driver code only needs to include the templated header file (which contains the class definition and the function prototypes) so that the first few lines of the modified driver code look like this\+: \textbackslash{}dontinclude two\+\_\+d\+\_\+poisson2.\+cc \textbackslash{}skipline Driver for \textbackslash{}until meshes/simple The driver code can now be compiled separately (without having to recompile the mesh sources every time) and the correctly instantiated version of the \textbackslash{}c Simple\+Rectangular\+Quad\+Mesh can be made available by including \textbackslash{}c two\+\_\+d\+\_\+poisson2\+\_\+mesh.\+o during the linking phase. \textbackslash{}subsection different\+\_\+solvers How to choose the linear solver for the Newton method \textbackslash{}c oomph-\/lib treats all problems as nonlinear problems and provides steady (and unsteady) Newton solvers to solve the system of nonlinear algebraic equations that arise from the spatial (and temporal) discretisation of the governing equations. Typically, the repeated assembly of the Jacobian matrix and the solution of the linear systems during the Newton iteration provides the major part of the computational work. Within this framework linear problems are simply special cases of nonlinear problems for which the Newton method converges in one iteration. The assembly of the Jacobian matrix and the solution of the linear system is performed by \textbackslash{}c oomph-\/lib\textquotesingle{}s \textbackslash{}c Linear\+Solver objects. These typically provide interfaces to general purpose linear solvers such as \textbackslash{}c Super\+L\+U\+Solver (our default solver). The list of solvers includes\+: -\/ \textbackslash{}c Super\+L\+U\+Solver\+: An interface to Demmel, Eistenstat, Gilbert, Li \& Liu\textquotesingle{}s serial Super\+LU solver. See $<$A H\+R\+EF=\char`\"{}http\+: http\+: -\/ \textbackslash{}c H\+S\+L\+\_\+\+M\+A42\+: An interface to the M\+A42 frontal solver from the H\+SL library. See $<$A H\+R\+EF=\char`\"{}http\+: http\+: for details. -\/ \textbackslash{}c F\+D\+\_\+\+L\+U\+: An extremely inefficient solver which computes the Jacobian matrix by finite differencing and stores it in a dense matrix. This solver is mainly provided to facilitate sanity checks during code development. (The residuals are easier to compute than the the Jacobian matrix!) -\/ ...and many others. See the $<$a href=\char`\"{}../../../linear\+\_\+solvers/html/index.\+html\char`\"{}$>$Linear Solvers Tutorial$<$/a$>$ for a more detailed discussion of \textbackslash{}c oomph-\/lib\textquotesingle{}s various direct and iterative solvers. . By default the \textbackslash{}c oomph-\/lib Newton solvers use \textbackslash{}c Super\+LU with compressed row storage for the Jacobian matrix as the linear solver. To change the linear solver to another type you can over-\/write the \textbackslash{}c Problem\textquotesingle{}s pointer to its linear solver. For instance, to change the linear solver to \textbackslash{}c H\+S\+L\+\_\+\+M\+A42, add the following lines to the \textbackslash{}c Problem constructor\+: \textbackslash{}code Problem\+::linear\+\_\+solver\+\_\+pt() = new H\+S\+L\+\_\+\+M\+A42}



Definition at line 408 of file two\+\_\+d\+\_\+poisson.\+txt.



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{two__d__poisson_8txt_adff9ced81c6476b852d5feaad9392c1b}\label{two__d__poisson_8txt_adff9ced81c6476b852d5feaad9392c1b}} 
\index{two\_d\_poisson.txt@{two\_d\_poisson.txt}!static\_cast$<$ HSL\_MA42 $\ast$ $>$@{static\_cast$<$ HSL\_MA42 $\ast$ $>$}}
\index{static\_cast$<$ HSL\_MA42 $\ast$ $>$@{static\_cast$<$ HSL\_MA42 $\ast$ $>$}!two\_d\_poisson.txt@{two\_d\_poisson.txt}}
\doxysubsubsection{\texorpdfstring{static\_cast$<$ HSL\_MA42 $\ast$ $>$()}{static\_cast< HSL\_MA42 * >()}}
{\footnotesize\ttfamily static\+\_\+cast$<$ H\+S\+L\+\_\+\+M\+A42 $\ast$ $>$ (\begin{DoxyParamCaption}\item[{Problem\+::linear\+\_\+solver\+\_\+pt()}]{ }\end{DoxyParamCaption}) -\/$>$  doc\+\_\+stats()=true}



Switch on full doc for frontal solver. 



\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}\label{two__d__poisson_8txt_a4074baada03976c061d5672f4237cca5}} 
\index{two\_d\_poisson.txt@{two\_d\_poisson.txt}!problem@{problem}}
\index{problem@{problem}!two\_d\_poisson.txt@{two\_d\_poisson.txt}}
\doxysubsubsection{\texorpdfstring{problem}{problem}}
{\footnotesize\ttfamily mainpage Demo problem}



Definition at line 2 of file two\+\_\+d\+\_\+poisson.\+txt.



Referenced by main(), and run().

